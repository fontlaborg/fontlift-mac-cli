Project Structure:
üìÅ fontlift-mac-cli
‚îú‚îÄ‚îÄ üìÅ .github
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ ISSUE_TEMPLATE
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ bug_report.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ feature_request.md
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ workflows
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ ci.yml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ release.yml
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ PULL_REQUEST_TEMPLATE.md
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ RELEASING.md
‚îú‚îÄ‚îÄ üìÅ issues
‚îú‚îÄ‚îÄ üìÅ scripts
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ get-version.sh
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ prepare-release.sh
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ validate-version.sh
‚îú‚îÄ‚îÄ üìÅ Sources
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ fontlift
‚îÇ       ‚îî‚îÄ‚îÄ üìÑ fontlift.swift
‚îú‚îÄ‚îÄ üìÅ testdata
‚îú‚îÄ‚îÄ üìÅ Tests
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ fontliftTests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ CLIErrorTests.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ HelperFunctionTests.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ ProjectValidationTests.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ UnregisterFontTests.swift
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ integration_test.sh
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ scripts_test.sh
‚îú‚îÄ‚îÄ üìÑ .gitignore
‚îú‚îÄ‚îÄ üìÑ build.sh
‚îú‚îÄ‚îÄ üìÑ CLAUDE.md
‚îú‚îÄ‚îÄ üìÑ DEPENDENCIES.md
‚îú‚îÄ‚îÄ üìÑ LICENSE
‚îú‚îÄ‚îÄ üìÑ Package.resolved
‚îú‚îÄ‚îÄ üìÑ Package.swift
‚îú‚îÄ‚îÄ üìÑ PLAN.md
‚îú‚îÄ‚îÄ üìÑ PRINCIPLES.md
‚îú‚îÄ‚îÄ üìÑ publish.sh
‚îú‚îÄ‚îÄ üìÑ README.md
‚îú‚îÄ‚îÄ üìÑ test.sh
‚îî‚îÄ‚îÄ üìÑ TODO.md


## .github/ISSUE_TEMPLATE/bug_report.md
````markdown
---
name: Bug Report
about: Report a bug or unexpected behavior
title: '[BUG] '
labels: bug
assignees: ''
---

## Bug Description
A clear description of what the bug is.

## Steps to Reproduce
1. Run command `fontlift ...`
2. Expected behavior...
3. Actual behavior...

## Environment
- **fontlift version**: (run `fontlift --version`)
- **macOS version**: (e.g., Sonoma 14.1)
- **Architecture**: (Intel or Apple Silicon)

## Command Output
```bash
# Paste the full command output here
```

## Expected Behavior
What you expected to happen.

## Actual Behavior
What actually happened.

## Additional Context
Any other information about the problem.
````

## .github/ISSUE_TEMPLATE/feature_request.md
```markdown
---
name: Feature Request
about: Suggest a new feature or enhancement
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

## Feature Description
A clear description of the feature you'd like to see.

## Use Case
Explain how this feature would be used and why it's valuable.

## Proposed Solution
How you envision this feature working.

## Alternatives Considered
Any alternative solutions or features you've considered.

## Additional Context
Any other information about the feature request.

## Scope Check
Please confirm this aligns with fontlift's core scope:
- [ ] This feature relates to installing, uninstalling, listing, or removing fonts
- [ ] This is not a major new feature outside core functionality
```

## .github/PULL_REQUEST_TEMPLATE.md
```markdown
## Description
Brief description of what this PR does.

## Type of Change
- [ ] Bug fix (non-breaking change fixing an issue)
- [ ] New feature (non-breaking change adding functionality)
- [ ] Breaking change (fix or feature causing existing functionality to change)
- [ ] Documentation update
- [ ] Performance improvement
- [ ] Code cleanup/refactoring

## Checklist
- [ ] Code follows project style and PRINCIPLES.md
- [ ] All tests pass locally (`./test.sh`)
- [ ] Added tests for new functionality
- [ ] Updated documentation (README.md, CHANGELOG.md)
- [ ] No compiler warnings
- [ ] Commit message follows conventional commits format
- [ ] Changes are focused and atomic

## Testing
Describe how you tested these changes:
- [ ] Ran full test suite (131 tests)
- [ ] Tested manually with real fonts
- [ ] Tested on both Intel and Apple Silicon (if applicable)

## Related Issues
Closes #(issue number)

## Additional Notes
Any other information reviewers should know.
```

## .github/RELEASING.md
````markdown
# Release Process

<!-- this_file: .github/RELEASING.md -->

This document describes the process for creating a new release of fontlift-mac-cli.

## Pre-Release Checklist

Before creating a release, ensure:

- [ ] All tests passing locally (`./test.sh`)
- [ ] All changes committed to `main` branch
- [ ] Git working directory is clean
- [ ] You're on the latest `main` branch (`git pull origin main`)

## Release Steps

### 1. Update Version Number

Edit `Sources/fontlift/fontlift.swift`:

```swift
private let version = "X.Y.Z"  // Update this line
```

**Version Number Guidelines:**
- **MAJOR** (X.0.0): Breaking changes, incompatible API changes
- **MINOR** (0.X.0): New features, backwards-compatible
- **PATCH** (0.0.X): Bug fixes, backwards-compatible

### 2. Update CHANGELOG.md

Add a new version section at the top (after `[Unreleased]`):

```markdown
## [X.Y.Z] - YYYY-MM-DD

### Added
- New features

### Changed
- Changes to existing features

### Fixed
- Bug fixes

### ‚ö†Ô∏è BREAKING CHANGES (if applicable)
- Description of breaking changes
- Migration instructions
```

**Important:** The release workflow extracts notes from CHANGELOG.md, so this section must exist and be properly formatted.

### 3. Commit Version Changes

```bash
git add Sources/fontlift/fontlift.swift CHANGELOG.md
git commit -m "chore: bump version to X.Y.Z"
```

### 4. Run Final Tests

```bash
./test.sh
```

Verify all 100 tests pass.

### 5. Create Git Tag

```bash
git tag -a vX.Y.Z -m "Release vX.Y.Z"
```

**Note:** Tag format must be `vX.Y.Z` (with `v` prefix).

### 6. Push to GitHub

```bash
git push origin main
git push origin vX.Y.Z
```

Pushing the tag triggers the automated release workflow.

### 7. Monitor Release Workflow

Watch the GitHub Actions workflow:

```bash
gh run watch
```

Or visit: https://github.com/fontlaborg/fontlift-mac-cli/actions

The release workflow will:
1. **Validate** version matches between tag and code (4-5s)
2. **Build** universal binary (x86_64 + arm64) (~60s)
3. **Create** GitHub Release with artifacts (~6s)

Total time: ~70 seconds

### 8. Verify Release

Check the release was created successfully:

```bash
gh release view vX.Y.Z
```

Or visit: https://github.com/fontlaborg/fontlift-mac-cli/releases/latest

Verify:
- [ ] Release page shows correct version
- [ ] CHANGELOG notes are extracted correctly
- [ ] Artifacts are attached: `fontlift-vX.Y.Z-macos.tar.gz` and `.sha256`
- [ ] Binary is universal (contains x86_64 and arm64)

### 9. Test Release Artifact (Optional)

Download and test the release binary:

```bash
# Download
cd /tmp
gh release download vX.Y.Z

# Verify checksum
shasum -a 256 -c fontlift-vX.Y.Z-macos.tar.gz.sha256

# Extract and test
tar -xzf fontlift-vX.Y.Z-macos.tar.gz
./fontlift --version  # Should show X.Y.Z
lipo -info ./fontlift  # Should show: x86_64 arm64

# Test functionality
./fontlift list | head -5
```

## Troubleshooting

### Version Mismatch Error

If the release workflow fails with "Version mismatch":

```bash
# The tag version doesn't match the code version
# Fix the version in Sources/fontlift/fontlift.swift
# Then delete and recreate the tag:
git tag -d vX.Y.Z
git push origin :vX.Y.Z
# Update the version, commit, and create tag again
```

### CHANGELOG Extraction Failed

If release notes are empty:

- Ensure CHANGELOG.md has a section: `## [X.Y.Z] - YYYY-MM-DD`
- Check the version number matches exactly (no `v` prefix in CHANGELOG)
- Ensure there's a blank line after the version header

### Build Failed

Check the workflow logs:

```bash
gh run view --log
```

Common issues:
- Swift compilation errors (check `swift build` locally)
- Universal build issues (check `./build.sh --universal` locally)

### Release Not Created

Verify:
- [ ] Tag was pushed: `git ls-remote --tags origin`
- [ ] Workflow was triggered: `gh run list --workflow=release.yml`
- [ ] Repository has Actions write permissions (Settings ‚Üí Actions ‚Üí General)

## Post-Release

After successful release:

1. Update local repository:
   ```bash
   git pull origin main --tags
   ```

2. Announce the release (if applicable):
   - Update project documentation
   - Notify users of breaking changes
   - Update Homebrew formula (if applicable)

3. Monitor for issues:
   - Watch GitHub Issues for bug reports
   - Check release download counts
   - Verify users can install successfully

## Rollback (Emergency)

If a critical bug is found after release:

1. **Quick fix**: Release a patch version (X.Y.Z+1) with the fix
2. **Major issue**: Mark the release as pre-release on GitHub while fixing

```bash
# Mark release as pre-release
gh release edit vX.Y.Z --prerelease

# After fix, create new release and unmark old one
gh release edit vX.Y.Z --not-prerelease=false
```

## Automation

The release process is largely automated via GitHub Actions:

- **CI Workflow** (`.github/workflows/ci.yml`): Runs on every push/PR
  - Validates version consistency:
    - Checks version format matches semver (X.Y.Z)
    - Verifies CHANGELOG.md has entry for current version
    - **Catches common errors:**
      - Invalid format like `1.0.0.0` (fails build)
      - Missing CHANGELOG entry (warns, but continues)
      - Non-numeric version components (fails build)
  - Builds the project
  - Runs all 100 tests
  - Validates code quality

- **Release Workflow** (`.github/workflows/release.yml`): Runs on version tags
  - Validates version consistency
  - Builds universal binary
  - Creates GitHub Release
  - Uploads artifacts with checksums

## Tips

- **Test the workflow**: Create a test tag like `v0.0.0-test` to verify the workflow works
- **Use semantic versioning**: Follow semver strictly for user expectations
- **Document breaking changes**: Always include migration guides for breaking changes
- **Keep CHANGELOG updated**: Update it with every significant change, not just at release time
- **Verify locally first**: Always test the full build and test suite before pushing tags

## Questions?

If you encounter issues not covered here:
1. Check recent release workflow logs: `gh run list --workflow=release.yml`
2. Review the GitHub Actions workflow files in `.github/workflows/`
3. Open an issue for documentation improvements

---

Last updated: 2025-11-03 (v2.0.0 release process)
````

## .github/workflows/ci.yml
```yaml
# this_file: .github/workflows/ci.yml
# Continuous Integration workflow for fontlift
# Runs on every push to main and on all pull requests

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  test:
    name: Build and Test
    runs-on: macos-14

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Display Swift version
        run: swift --version

      - name: Validate version consistency
        run: |
          # Extract version from code
          CODE_VERSION=$(./scripts/get-version.sh)
          echo "Code version: $CODE_VERSION"

          # Verify version format (semver)
          if ! [[ "$CODE_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå Error: Invalid version format in code: $CODE_VERSION"
            echo "   Expected format: X.Y.Z (semantic versioning)"
            exit 1
          fi

          # Check if CHANGELOG.md has a section for this version
          if ! grep -q "^## \[$CODE_VERSION\]" CHANGELOG.md; then
            echo "‚ö†Ô∏è  Warning: No CHANGELOG.md entry found for version $CODE_VERSION"
            echo "   Add a section: ## [$CODE_VERSION] - YYYY-MM-DD"
            echo "   This is a warning only - build will continue"
          else
            echo "‚úÖ CHANGELOG.md entry exists for version $CODE_VERSION"
          fi

      - name: Build
        run: ./build.sh --ci

      - name: Run tests
        run: ./test.sh --ci

      - name: Verify binary
        run: |
          .build/release/fontlift --version
          .build/release/fontlift --help
```

## .github/workflows/release.yml
```yaml
# this_file: .github/workflows/release.yml
# Continuous Deployment workflow for fontlift
# Runs when version tags (vX.Y.Z) are pushed
# Creates GitHub Release with binary artifacts

name: Release

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write  # Required to create releases

jobs:
  validate:
    name: Validate Version
    runs-on: macos-14
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Extract tag version
        id: tag
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Validate version matches code
        run: ./scripts/validate-version.sh ${{ steps.tag.outputs.VERSION }}

  build:
    name: Build Release Binary
    needs: validate
    runs-on: macos-14
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Display Swift version
        run: swift --version

      - name: Build release binary (universal)
        run: ./build.sh --ci --universal

      - name: Prepare release artifacts
        run: ./scripts/prepare-release.sh

      # Note: Tests are already run in CI workflow on every push
      # Running tests here would overwrite the universal binary with a native-only debug binary

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: fontlift-macos
          path: dist/*
          retention-days: 90

  release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: fontlift-macos
          path: dist/

      - name: Extract version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Extract release notes
        id: notes
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          # Extract version section from CHANGELOG.md
          sed -n "/## \[${VERSION}\]/,/## \[/p" CHANGELOG.md | sed '$d' > release_notes.md
          # If release notes are empty, use a default message
          if [ ! -s release_notes.md ]; then
            echo "Release ${VERSION}" > release_notes.md
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## .gitignore
```
# Xcode
#
# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore

## User settings
xcuserdata/

## Obj-C/Swift specific
*.hmap

## App packaging
*.ipa
*.dSYM.zip
*.dSYM

## Playgrounds
timeline.xctimeline
playground.xcworkspace

# Swift Package Manager
#
# Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
# Packages/
# Package.pins
# Package.resolved
# *.xcodeproj
#
# Xcode automatically generates this directory with a .xcworkspacedata file and xcuserdata
# hence it is not needed unless you have added a package configuration file to your project
# .swiftpm

.build/

# CocoaPods
#
# We recommend against adding the Pods directory to your .gitignore. However
# you should judge for yourself, the pros and cons are mentioned at:
# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
#
# Pods/
#
# Add this line if you want to avoid checking in source code from the Xcode workspace
# *.xcworkspace

# Carthage
#
# Add this line if you want to avoid checking in source code from Carthage dependencies.
# Carthage/Checkouts

Carthage/Build/

# fastlane
#
# It is recommended to not store the screenshots in the git repo.
# Instead, use fastlane to re-generate the screenshots whenever they are needed.
# For more information about the recommended setup visit:
# https://docs.fastlane.tools/best-practices/source-control/#source-control

fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output

# macOS
.DS_Store
.AppleDouble
.LSOverride

# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# Swift
*.swiftmodule
*.swiftdoc
*.swiftsourceinfo
.swiftpm/

# GitHub Actions logs (auto-generated, tracked separately in issues/)
issues/logs/

# Distribution artifacts (generated during releases)
dist/

# IDE files
*.swp
*.swo
*~
.vscode/
.idea/

# Temporary files
*.tmp
*.log
*.bak
*.orig

# Xcode build artifacts
*.xcarchive
DerivedData/
*.moved-aside
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3
```

## CLAUDE.md
````markdown
# Development Guidelines

## Quick-Start Checklist

**For every task, follow this baseline:**

1. [ ] Read `README.md`, `PLAN.md`, `TODO.md`, `WORK.md` to understand context
2. [ ] Apply Chain-of-Thought: "Let me think step by step..."
3. [ ] Search when <90% confident (codebase, references, web)
4. [ ] Check if this problem has been solved before (packages > custom code)
5. [ ] Write the test FIRST, then minimal code to pass
6. [ ] Test edge cases (empty, None, negative, huge inputs)
7. [ ] Run full test suite after changes
8. [ ] Update documentation (`WORK.md`, `CHANGELOG.md`)
9. [ ] Self-correct: "Wait, but..." and critically review
10. [ ] Delete rather than add when possible

## Normative Language Convention

- **MUST** ‚Äì Hard requirements, no exceptions
- **SHOULD** ‚Äì Default behavior; deviate only with clear justification  
**MAY** ‚Äì Optional practices or suggestions

---

## I. OPERATING MODEL

You are a Senior Software Engineer obsessed with ruthless minimalism, absolute accuracy, and rigorous verification. You are skeptical of complexity, assumptions, and especially your own first instincts.

### 1.1 Enhanced Chain-of-Thought Process (MUST)

Before ANY response, apply this three-phase thinking:

1. **Analyze** ‚Äì "Let me think step by step..."
   - Deconstruct the request completely
   - Identify constraints and edge cases
   - Question implicit assumptions

2. **Abstract (Step-Back)** ‚Äì Zoom out before diving in
   - What high-level patterns apply?
   - What are 2-3 viable approaches?
   - What are the trade-offs?

3. **Execute** ‚Äì Select the most minimal, verifiable path
   - Your output MUST be what you'd produce after finding and fixing three critical issues

### 1.2 Communication: Anti-Sycophancy (MUST)

**Accuracy is non-negotiable. Facts over feelings.**

- **NEVER** use validation phrases: "You're right", "Great idea", "Exactly"
- **ALWAYS** challenge incorrect statements immediately with "Actually, that's incorrect because..."
- **MUST** state confidence explicitly:
  - "I'm certain (>95% confidence)"
  - "I believe (70-95% confidence)" 
  - "This is an educated guess (<70% confidence)"
- When <90% confident, **MUST** search before answering
- LLMs can hallucinate ‚Äì treat all outputs (including your own) with skepticism

### 1.3 Mandatory Self-Correction Phase (MUST)

After drafting any solution:

1. Say "Wait, but..." and critique ruthlessly
2. Check: Did I add unnecessary complexity? Are there untested assumptions? 
3. Revise based on the critique before delivering

### 1.4 Context Awareness (SHOULD)

- **FREQUENTLY** state which project/directory you're working in
- **ALWAYS** explain the WHY behind changes
- No need for manual `this_file` tracking ‚Äì that's impractical overhead

---

## II. CORE PHILOSOPHY

### 2.1 The Prime Directive: Ruthless Minimalism (MUST)

**Complexity is debt. Every line of code is a liability.**

- **YAGNI**: Build only what's required NOW
- **Delete First**: Can we remove code instead of adding?
- **One-Sentence Scope**: Define project scope in ONE sentence and reject everything else

### 2.2 Build vs Buy (MUST Prefer Buy)

**Package-First Workflow:**

1. **Search** existing solutions (PyPI, npm, crates.io, GitHub)
2. **Evaluate** packages: >1000 stars, recent updates, good docs, minimal deps
3. **Prototype** with a small PoC to verify
4. **Use** the package ‚Äì only write custom code if no suitable package exists

### 2.3 Test-Driven Development (MUST)

**Untested code is broken code.**

1. **RED** ‚Äì Write a failing test first
2. **GREEN** ‚Äì Write minimal code to pass
3. **REFACTOR** ‚Äì Clean up while keeping tests green
4. **VERIFY** ‚Äì Test edge cases, error conditions, integration

### 2.4 Complexity Triggers ‚Äì STOP Immediately If You See:

- "General purpose" utility functions
- Abstractions for "future flexibility"
- Custom parsers, validators, formatters
- Any Manager/Handler/System/Framework class
- Functions >20 lines, Files >200 lines, >3 indentation levels
- Security hardening, performance monitoring, analytics

---

## III. STANDARD OPERATING PROCEDURE

### 3.1 Before Starting (MUST)

1. Read `README.md`, `WORK.md`, `CHANGELOG.md`, `PLAN.md`, `TODO.md`
2. Run existing tests to understand current state
3. Apply Enhanced CoT (Analyze ‚Üí Abstract ‚Üí Execute)
4. Search for existing solutions before writing code

### 3.2 During Work ‚Äì Baseline Mode (MUST)

For **every** change:

1. Write test first
2. Implement minimal code
3. Run tests
4. Document in `WORK.md`

### 3.3 During Work ‚Äì Enhanced Mode (SHOULD for major changes)

For significant features or risky changes:

1. All baseline steps PLUS:
2. Test all edge cases comprehensively
3. Test error conditions (network, permissions, missing files)
4. Performance profiling if relevant
5. Security review if handling user input
6. Update all related documentation

### 3.4 After Work (MUST)

1. Run full test suite
2. Self-correction phase: "Wait, but..."
3. Update `CHANGELOG.md` with changes
4. Update `TODO.md` status markers
5. Verify nothing broke

---

## IV. LANGUAGE-SPECIFIC GUIDELINES

### 4.1 Python

#### Modern Toolchain (MUST)

- **Package Management**: `uv` exclusively (not pip, not conda)
- **Python Version**: 3.12+ via `uv` (never system Python)
- **Virtual Environments**: Always use `uv venv`
- **Formatting & Linting**: `ruff` (replaces black, flake8, isort, pyupgrade)
- **Type Checking**: `mypy` or `pyright` (mandatory for all code)
- **Testing**: `pytest` with `pytest-cov`, `pytest-randomly`

#### Project Layout (SHOULD)

```
project/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ package_name/
‚îú‚îÄ‚îÄ tests/
‚îú‚îÄ‚îÄ pyproject.toml
‚îî‚îÄ‚îÄ README.md
```

#### Core Packages to Prefer (SHOULD)

- **CLI**: `typer` or `fire` + `rich` for output
- **HTTP**: `httpx` (not requests)
- **Data Validation**: `pydantic` v2
- **Logging**: `loguru` or `structlog` (structured logs)
- **Async**: `asyncio` with `FastAPI` for web
- **Data Formats**: JSON, SQLite, Parquet (not CSV for production)
- **Config**: Environment variables or TOML (via `tomllib`)

#### Code Standards (MUST)

- Type hints on EVERY function
- Docstrings explaining WHAT and WHY
- Use dataclasses or Pydantic for data structures
- `pathlib` for paths (not os.path)
- f-strings for formatting

#### Testing (MUST)

```bash
# Run with coverage
pytest --cov=src --cov-report=term-missing --cov-fail-under=80

# With ruff cleanup
uvx ruff check --fix . && uvx ruff format . && pytest
```

### 4.2 Rust

#### Toolchain (MUST)

- **Build**: `cargo` for everything
- **Format**: `cargo fmt` (no exceptions)
- **Lint**: `cargo clippy -- -D warnings`
- **Security**: `cargo audit` and `cargo deny`

#### Core Principles (MUST)

- **Ownership First**: Leverage the type system to prevent invalid states
- **Minimize `unsafe`**: Isolate, document, and audit any unsafe code
- **Error Handling**: Use `Result<T, E>` everywhere
  - Libraries: `thiserror` for error types
  - Applications: `anyhow` for error context
- **No `panic!` in libraries**: Only in truly unrecoverable situations

#### Concurrency (SHOULD)

- **Async Runtime**: `tokio` (default choice)
- **HTTP**: `reqwest` or `axum`
- **Serialization**: `serde` with `serde_json`
- **CLI**: `clap` with derive macros
- **Logging**: `tracing` with `tracing-subscriber`

#### Security (MUST)

- Enable integer overflow checks in debug
- Validate ALL external input
- Use `cargo-audit` in CI
- Prefer safe concurrency primitives (`Arc`, `Mutex`) 
- Use vetted crypto crates only (`ring`, `rustls`)

### 4.3 Web Development

#### Frontend (TypeScript/React)

##### Toolchain (MUST)

- **Package Manager**: `pnpm` (not npm, not yarn)
- **Bundler**: `vite` 
- **TypeScript**: `strict: true` in tsconfig.json
- **Framework**: Next.js (React) or SvelteKit (Svelte)
- **Styling**: Tailwind CSS
- **State**: Local state first, then Zustand/Jotai (avoid Redux)

##### Core Requirements (MUST)

- **Mobile-First**: Design for mobile, enhance for desktop
- **Accessibility**: WCAG 2.1 AA compliance minimum
- **Performance**: Optimize Core Web Vitals (LCP < 2.5s, FID < 100ms)
- **Security**: Sanitize inputs, implement CSP headers
- **Type Safety**: Zod for runtime validation at API boundaries

##### Best Practices (SHOULD)

- Server-side rendering for initial page loads
- Lazy loading for images and components
- Progressive enhancement
- Semantic HTML
- Error boundaries for graceful failures

#### Backend (Node.js/API)

##### Standards (MUST)

- **Framework**: Express with TypeScript or Fastify
- **Validation**: Zod or Joi for input validation
- **Auth**: Use established libraries (Passport, Auth0)
- **Database**: Prisma or Drizzle ORM
- **Testing**: Vitest or Jest with Supertest

##### Security (MUST)

- Rate limiting on all endpoints
- HTTPS only
- Helmet.js for security headers
- Input sanitization
- SQL injection prevention via parameterized queries

---

## V. PROJECT DOCUMENTATION

### Required Files (MUST maintain)

- **README.md** ‚Äì Purpose and quick start (<200 lines)
- **CHANGELOG.md** ‚Äì Cumulative release notes
- **PLAN.md** ‚Äì Detailed future goals and architecture
- **TODO.md** ‚Äì Flat task list from PLAN.md with status:
  - `[ ]` Not started
  - `[x]` Completed  
  - `[~]` In progress
  - `[-]` Blocked
  - `[!]` High priority
- **WORK.md** ‚Äì Current work log with test results
- **DEPENDENCIES.md** ‚Äì Package list with justifications

---

## VI. SPECIAL COMMANDS

### `/plan [requirement]` (Enhanced Planning)

When invoked, MUST:

1. **Research** existing solutions extensively
2. **Deconstruct** into core requirements and constraints
3. **Analyze** feasibility and identify packages to use
4. **Structure** into phases with dependencies
5. **Document** in PLAN.md with TODO.md checklist

### `/test` (Comprehensive Testing)

**Python:**
```bash
uvx ruff check --fix . && uvx ruff format . && pytest -xvs
```

**Rust:**
```bash
cargo fmt --check && cargo clippy -- -D warnings && cargo test
```

**Then** perform logic verification on changed files and document in WORK.md

### `/work` (Execution Loop)

1. Read TODO.md and PLAN.md
2. Write iteration goals to WORK.md
3. **Write tests first**
4. Implement incrementally
5. Run /test continuously
6. Update documentation
7. Continue to next item

### `/report` (Progress Update)

1. Analyze recent changes
2. Run full test suite
3. Update CHANGELOG.md
4. Clean up completed items from TODO.md

---

## VII. LLM PROMPTING PATTERNS

### Chain-of-Thought (CoT)

For complex reasoning tasks, ALWAYS use:
```
"Let me think step by step...
1. First, I need to...
2. Then, considering...
3. Therefore..."
```

### ReAct Pattern (for Tool Use)

When using external tools:
```
Thought: What information do I need?
Action: [tool_name] with [parameters]
Observation: [result]
Thought: Based on this, I should...
```

### Self-Consistency

For critical decisions:
1. Generate multiple solutions
2. Evaluate trade-offs
3. Select best approach with justification

### Few-Shot Examples

When generating code/tests, provide a minimal example first:
```python
# Example test pattern:
def test_function_when_valid_input_then_expected_output():
    result = function(valid_input)
    assert result == expected, "Clear failure message"
```

---

## VIII. ANTI-BLOAT ENFORCEMENT

### Scope Discipline (MUST)

Define scope in ONE sentence. Reject EVERYTHING else.

### RED LIST ‚Äì NEVER Add Unless Explicitly Required:

- Analytics/metrics/telemetry
- Performance monitoring/profiling  
- Production error frameworks
- Advanced security beyond input validation
- Health monitoring/diagnostics
- Circuit breakers/sophisticated retry
- Complex caching systems
- Configuration validation frameworks
- Backup/recovery mechanisms
- Benchmarking suites

### GREEN LIST ‚Äì Acceptable Additions:

- Basic try/catch error handling
- Simple retry (‚â§3 attempts)
- Basic logging (print or loguru)
- Input validation for required fields
- Help text and examples
- Simple config files (TOML)
- Core functionality tests

### Complexity Limits (MUST)

- Simple utilities: 1-3 commands
- Standard tools: 4-7 commands  
- Over 8 commands: Probably over-engineered
- Could fit in one file? Keep it in one file
- Weekend rewrite test: If it takes longer, it's too complex

---

## IX. PROSE WRITING

When writing documentation or commentary:

- **First line sells the second line** ‚Äì No throat-clearing
- **Transformation over features** ‚Äì Show the change, not the tool
- **One person, one problem** ‚Äì Specific beats generic
- **Conflict creates interest** ‚Äì What's at stake?
- **Kill your darlings** ‚Äì If it doesn't serve the reader, delete it
- **Enter late, leave early** ‚Äì Start in action, end before over-explaining
- **No corporate jargon** ‚Äì Clear, concrete language only
- **Light humor allowed** ‚Äì But clarity comes first
- **Skepticism is healthy** ‚Äì Question everything, including this guide

---

**Remember: The best code is no code. The second best is someone else's well-tested code. Write as little as possible, test everything, and delete ruthlessly.**

## Gemini Added Memories
- I must always ask for confirmation before running any command that deletes files. The user must explicitly approve the deletion. I should explain what the command does and which files will be deleted.
All files, usage notes, GUIs, CLI helps, documentation etc. should carry a mention `made by FontLab https://www.fontlab.com/` where it makes sense.
````

## DEPENDENCIES.md
````markdown
# DEPENDENCIES.md
<!-- this_file: DEPENDENCIES.md -->

This document lists all external dependencies and explains why each was chosen.

## Runtime Dependencies

### Swift Argument Parser
- **Version**: 1.6.2
- **Repository**: https://github.com/apple/swift-argument-parser
- **License**: Apache 2.0
- **Stars**: 3.3k+
- **Maintenance**: Active (Apple maintained)

**Why chosen**:
- Type-safe, declarative CLI argument parsing
- Official Apple package with excellent support
- Automatic help generation and validation
- Clean, modern Swift API
- Reduces boilerplate significantly vs manual parsing
- Well-documented with extensive examples
- Zero additional dependencies
- Perfect fit for our use case (CLI with subcommands)

**Alternative considered**:
- Manual argument parsing using CommandLine.arguments
  - **Pros**: No dependencies, full control
  - **Cons**: More code, more bugs, no help generation, no validation
  - **Decision**: ArgumentParser provides better quality and maintainability

## Development Dependencies

None currently. All testing uses built-in XCTest framework.

## System Dependencies

### macOS Core Text Framework
- **Version**: Built into macOS
- **Minimum**: macOS 12 (Monterey)
- **Purpose**: Font registration and management

**Why chosen**:
- Native macOS API for font operations
- No external dependencies
- Official Apple framework
- Direct access to font registration/unregistration
- Handles font collections (.ttc/.otc) correctly
- Required for core functionality

## Dependency Policy

Following PRINCIPLES.md, we:
- Minimize dependencies ruthlessly
- Prefer well-maintained packages (>200 stars, active development)
- Use macOS native frameworks when possible
- Avoid enterprise bloat (no logging frameworks, monitoring, analytics)
- Choose simplicity over flexibility
- Only add dependencies for core functionality

## Dependency Updates

Check for updates quarterly:
```bash
swift package update
```

Review release notes before updating major versions.
````

## LICENSE
```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```

## PLAN.md
```markdown
# PLAN.md
<!-- this_file: PLAN.md -->

## Project Overview

**fontlift-mac-cli** - Simple macOS CLI tool for font management

**One-sentence scope**: Install, uninstall, list, and remove fonts on macOS via CLI.
```

## PRINCIPLES.md
```markdown
# PRINCIPLES.md

## Core Principles for fontlift-mac-cli

### Scope adherence
- One sentence scope: Install, uninstall, list, and remove fonts on macOS via CLI, supporting both file paths and internal font names.
- No feature creep beyond core font operations.
- No enterprise bloat (analytics, monitoring, complex logging).

### Simplicity first
- Minimal dependencies: Use macOS native frameworks (Core Text, FileManager).
- Single-purpose functions: Each function does one thing well.
- Clear error messages: Tell users exactly what went wrong and how to fix it.

### Safety by default
- Confirm before destructive operations (remove command).
- Validate inputs before acting on them.
- Handle font collections (.ttc/.otc) correctly.
- Prevent deletion of system fonts.

### Build and release
- **Required**: Repository must have `./build.sh` for building the project.
- **Required**: Repository must have `./publish.sh` for releasing/publishing.
- Build scripts should be simple, documented, and work out of the box.

### Testing rigor
- Every function must have tests.
- Test edge cases: invalid files, permissions, missing fonts.
- Integration tests with real font operations.
- Manual verification in Font Book.

### Code quality
- Swift naming conventions (camelCase, descriptive).
- Prefer Swift error handling (`throws`, `Result`) over error codes.
- Keep functions under 20 lines.
- Keep files under 200 lines.
- Maintain `this_file` path comments in all source files.

### macOS native approach
- Use Core Text APIs correctly.
- Respect user vs system font scope.
- Follow macOS conventions for CLI tools.
- Handle permissions gracefully.
```

## Package.resolved
```
{
  "originHash" : "adbc4b168c1b1f7891530ddb1504296e6706970bfa32755e19a90e2f2660f22a",
  "pins" : [
    {
      "identity" : "swift-argument-parser",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/apple/swift-argument-parser.git",
      "state" : {
        "revision" : "cdd0ef3755280949551dc26dee5de9ddeda89f54",
        "version" : "1.6.2"
      }
    }
  ],
  "version" : 3
}
```

## Package.swift
```swift
// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "fontlift",
    platforms: [
        .macOS(.v12)  // macOS Monterey or later
    ],
    products: [
        // Executable product name defines the installed binary name.
        .executable(name: "fontlift-mac", targets: ["fontlift"])
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-argument-parser.git", from: "1.5.0")
    ],
    targets: [
        .executableTarget(
            name: "fontlift",
            dependencies: [
                .product(name: "ArgumentParser", package: "swift-argument-parser")
            ]
        ),
        .testTarget(
            name: "fontliftTests",
            dependencies: ["fontlift"]
        )
    ]
)
```

## README.md
````markdown
# fontlift-mac-cli

[![CI](https://github.com/fontlaborg/fontlift-mac-cli/workflows/CI/badge.svg)](https://github.com/fontlaborg/fontlift-mac-cli/actions)

CLI tool written in Swift for macOS to install/uninstall fonts

## Installation

### From GitHub Releases (Recommended)

Download and install the latest pre-built universal binary (supports both Intel and Apple Silicon):

```bash
# Set version (or use 'latest')
VERSION="2.0.0"  # Or check https://github.com/fontlaborg/fontlift-mac-cli/releases

# Download release tarball and checksum
curl -L "https://github.com/fontlaborg/fontlift-mac-cli/releases/download/v${VERSION}/fontlift-mac-v${VERSION}-macos.tar.gz" -o fontlift-mac.tar.gz
curl -L "https://github.com/fontlaborg/fontlift-mac-cli/releases/download/v${VERSION}/fontlift-mac-v${VERSION}-macos.tar.gz.sha256" -o fontlift-mac.tar.gz.sha256

# Verify checksum (recommended)
shasum -a 256 -c fontlift-mac.tar.gz.sha256

# Extract binary
tar -xzf fontlift-mac.tar.gz

# Install to /usr/local/bin (may require sudo)
sudo mv fontlift-mac /usr/local/bin/

# Verify installation
fontlift-mac --version
```

**Troubleshooting:** If you encounter issues, see [TROUBLESHOOTING.md](./TROUBLESHOOTING.md)

### Via Homebrew (Coming Soon)

Homebrew formula submission is planned for a future release:

```bash
# Future installation method (not yet available)
brew tap fontlaborg/fontlift
brew install fontlift-mac
```

**Requirements:**
- macOS 12.0 (Monterey) or later
- Intel (x86_64) or Apple Silicon (arm64) Mac

### From Source

Requires Swift 5.9+ and macOS 12+:

```bash
git clone https://github.com/fontlaborg/fontlift-mac-cli.git
cd fontlift-mac-cli
./build.sh
./publish.sh  # Installs to /usr/local/bin
```

## Quick Start

Here are the most common workflows:

### Discover available fonts
```bash
# List all installed fonts (sorted by family)
fontlift-mac list -n -s

# Find fonts matching a name
fontlift-mac list -n | grep -i "helvetica"

# See where a font is installed (shows path::name format)
fontlift-mac list -p -n | grep "Helvetica"
# Example output:
# /System/Library/Fonts/Helvetica.ttc::Helvetica
# /System/Library/Fonts/Helvetica.ttc::Helvetica-Bold
# Output is always sorted. Path-only listings are deduped automatically; add -s to dedupe names or path::name pairs.
```

### Install a new font
```bash
# Install a single font file
fontlift-mac install ~/Downloads/MyFont.ttf

# Install works with .ttf, .otf, .ttc, .otc files
fontlift-mac install /path/to/font.otf
```

### Uninstall a font (keep file)
```bash
# Uninstall by file path
fontlift-mac uninstall ~/Library/Fonts/MyFont.ttf

# Uninstall by font name
fontlift-mac list -n | grep "MyFont"  # Find exact name first
fontlift-mac uninstall -n "MyFont-Regular"
```

### Remove a font (delete file)
```bash
# Remove by file path (deletes file)
fontlift-mac remove ~/Downloads/OldFont.ttf

# Remove by font name (deletes file)
fontlift-mac remove -n "OldFont-Bold"
```

### Clean up font registrations and caches
```bash
# Prune missing font registrations and clear caches for the current user
fontlift-mac cleanup

# Only prune registrations (skip caches)
fontlift-mac cleanup --prune-only

# Only clear caches (prunes are skipped)
fontlift-mac cleanup --cache-only

# Run a system-level cleanup (clears caches for all users; requires sudo)
sudo fontlift-mac cleanup --admin
```

The default cleanup command performs two safety tasks:

- **Prunes missing fonts** ‚Äì removes registrations for fonts whose files were deleted or moved (skips protected system directories)
- **Clears caches** ‚Äì purges Core Text caches and third-party caches for Adobe and Microsoft apps (user scope by default, system scope with `--admin`)

## Advanced Usage Examples

### Installing a Custom Font Family

Installing all fonts from a downloaded font family:

```bash
# Download and install a font family (e.g., Inter from Google Fonts)
cd ~/Downloads
unzip Inter.zip -d Inter/

# Install all font files in the directory
for font in Inter/*.ttf; do
    fontlift-mac install "$font"
done

# Verify installation
fontlift-mac list -n | grep "Inter"
```

### Batch Font Management

Managing multiple fonts at once:

```bash
# List all fonts in a specific directory
ls ~/Library/Fonts/*.ttf

# Remove all fonts from a specific directory
for font in ~/Library/Fonts/CustomFonts/*.ttf; do
    fontlift-mac remove "$font"
done

# Reinstall fonts after system upgrade
find ~/FontBackup -name "*.ttf" -o -name "*.otf" | while read font; do
    fontlift-mac install "$font"
done
```

### Troubleshooting Font Installation

If you encounter issues installing fonts:

```bash
# 1. Check if font file exists and is readable
ls -la /path/to/font.ttf
file /path/to/font.ttf

# 2. Try installing with full path
fontlift-mac install "$(pwd)/MyFont.ttf"

# 3. Check if font is already installed
fontlift-mac list -n | grep -i "myfont"

# 4. If installation fails, check system font cache
# (macOS will rebuild it automatically)
atsutil databases -remove  # Requires sudo
```

### Verifying Installed Fonts

Comprehensive font verification:

```bash
# List all installed fonts (sorted alphabetically)
fontlift-mac list -n -s > installed-fonts.txt

# Count total installed fonts
fontlift-mac list -n | wc -l

# Find duplicate font names
fontlift-mac list -n | sort | uniq -d

# Find fonts by family
fontlift-mac list -n | grep -i "helvetica"

# Get both path and name for specific font
fontlift-mac list -n -p | grep "Helvetica"
```

## Usage

### Listing installed fonts

- `fontlift-mac list` or `fontlift-mac list -p` lists the paths of all installed fonts, one path per line
- `fontlift-mac list -n` lists the internal font names of all installed fonts, one name per line
- `fontlift-mac list -n -p` or `fontlift-mac list -p -n` lists the paths and internal font names of all installed fonts; each line consists of the path followed by double colon (`::`) followed by the internal font name
- `l` should be a synonym for `list`

### Installing fonts

- `fontlift-mac install FILEPATH` or `fontlift-mac install -p FILEPATH` installs on the system the font (or all fonts in case of a .ttc or .otc) from the FILEPATH for the current user
- `sudo fontlift-mac install --admin FILEPATH` or `sudo fontlift-mac install -a FILEPATH` installs the font at system level (all users in current login session)
- `i` should be a synonym for `install`

**User-level vs System-level:**
- User-level (default): Font available only to the current user, no sudo required
- System-level (`--admin` flag): Font available to all users in the current login session, requires sudo

### Uninstalling fonts while keeping the font files

- `fontlift-mac uninstall FILEPATH` or `fontlift-mac uninstall -p FILEPATH` uninstalls from the system the font (or all fonts in case of a .ttc or .otc) with the FILEPATH (keeps the file, user-level)
- `fontlift-mac uninstall -n FONTNAME` uninstalls the font with the given internal font name from the system (keeps the file, user-level)
- `sudo fontlift-mac uninstall --admin FILEPATH` or `sudo fontlift-mac uninstall -a -n FONTNAME` uninstalls at system level (all users, requires sudo)
- `u` should be the synonym for `uninstall`

### Uninstalling fonts and removing the font files

- `fontlift-mac remove FILEPATH` or `fontlift-mac remove -p FILEPATH` uninstalls from the system the font (or all fonts in case of a .ttc or .otc) with the FILEPATH (and removes the file, user-level)
- `fontlift-mac remove -n FONTNAME` uninstalls the font with the given internal font name from the system (and removes the file, user-level)
- `sudo fontlift-mac remove --admin FILEPATH` or `sudo fontlift-mac remove -a -n FONTNAME` removes at system level (all users, requires sudo)
- `rm` should be the synonym for `remove`

### Exit Codes

`fontlift-mac` follows standard Unix exit code conventions:

- `0` - Success: Command completed successfully
- `1` - Failure: Command failed (file not found, permission denied, invalid input, etc.)

**Examples in shell scripts:**

```bash
# Check if font installed successfully
if fontlift-mac install /path/to/font.ttf; then
    echo "Font installed successfully"
else
    echo "Failed to install font"
fi

# Capture exit code
fontlift-mac list > fonts.txt
EXIT_CODE=$?
if [ $EXIT_CODE -eq 0 ]; then
    echo "Successfully listed fonts"
fi
```

---

## Development

For development instructions, build automation, and release process:
- See [CLAUDE.md](./CLAUDE.md) for detailed development guidelines
- See [CHANGELOG.md](./CHANGELOG.md) for version history
- See [PLAN.md](./PLAN.md) for implementation plans

### Quick Start

```bash
# Build
./build.sh

# Test
./test.sh

# Local install
./publish.sh
```

### Developer Tools

The project includes several developer tools for quality assurance:

```bash
# Verify CI/CD workflows are configured correctly
./test.sh --verify-ci

# Verify build reproducibility (detects non-deterministic builds)
./build.sh --verify-reproducible

# Install pre-commit hook (optional, helps catch issues before committing)
cp .git-hooks/pre-commit .git/hooks/pre-commit
chmod +x .git/hooks/pre-commit
```

**Pre-commit hook checks**:
- Version consistency between source and commits
- CHANGELOG.md updates when code changes
- Quick smoke test (build + unit tests)

To bypass the hook when needed: `git commit --no-verify`

### Developer Scripts Reference

**build.sh** - Build the binary

```bash
./build.sh              # Normal release build
./build.sh --ci         # CI mode (quiet output)
./build.sh --clean      # Clean rebuild (removes .build/)
./build.sh --universal  # Build universal binary (x86_64 + arm64)
./build.sh --verify-reproducible  # Check build reproducibility
```

**test.sh** - Run all tests

```bash
./test.sh                    # Run all 124 tests (57 Swift + 23 Scripts + 44 Integration)
./test.sh --ci               # CI mode (quiet output, no colors)
./test.sh --swift            # Run only Swift unit tests (57 tests)
./test.sh --scripts          # Run only scripts tests (23 tests)
./test.sh --integration      # Run only integration tests (44 tests)
./test.sh --swift --ci       # Combine flags: Swift tests in CI mode
./test.sh --help             # Show all available options
```

**When to use selective test suite execution:**
- `--swift`: During core logic development, fast iteration (~6s)
- `--scripts`: When modifying build/test scripts (~20s)
- `--integration`: After binary changes, end-to-end validation (~10s)
- Combined: `--swift --integration` for focused testing without scripts
- Full suite: Default behavior, recommended before commits (~35s)

**scripts/prepare-release.sh** - Prepare release artifacts

```bash
./scripts/prepare-release.sh
# Creates dist/fontlift-mac-vX.Y.Z-macos.tar.gz and SHA256 checksum
# Requires universal binary (x86_64 + arm64)
```

**scripts/commit-helper.sh** - Guided commit workflow

```bash
./scripts/commit-helper.sh
# Validates: version consistency, CHANGELOG updates, tests, CI config
# Provides commit message template
# Safer than manual git commit
```

**scripts/verify-release-artifact.sh** - Verify published releases

```bash
./scripts/verify-release-artifact.sh 1.1.27
# Downloads release from GitHub
# Verifies checksum integrity
# Tests binary functionality
```

### CI/CD

This project uses GitHub Actions for automated testing and releases:
- **CI**: Runs on every push/PR (builds and tests)
- **CD**: Triggered by version tags (`vX.Y.Z`) to create GitHub Releases

View build status: [GitHub Actions](https://github.com/fontlaborg/fontlift-mac-cli/actions)

---

- Copyright 2025 by Fontlab Ltd.
- made by FontLab https://www.fontlab.com/
- Licensed under Apache 2.0
- Repo: https://github.com/fontlaborg/fontlift-mac-cli
````

## Sources/fontlift/fontlift.swift
````swift
// this_file: Sources/fontlift/fontlift.swift
// fontlift-mac - macOS CLI tool for font installation and management
// UI terminology note: user-facing copy intentionally says "font" for clarity;
// internal data flows use Fontlift* types per the naming policy.

import ArgumentParser
import CoreText
import Foundation
import Darwin

// MARK: - Version Management
/// Current version of fontlift-mac
/// When updating, also update:
/// - CHANGELOG.md (add new version section)
/// - Git tag (git tag vX.Y.Z)
private let fontLabAttribution = "made by FontLab https://www.fontlab.com/"
private let version = "2.0.0"
private let binaryName = "fontlift-mac"
private let fakeRegistrationMode = ProcessInfo.processInfo.environment["FONTLIFT_FAKE_REGISTRATION"] == "1"
private let overrideUserLibraryPath = ProcessInfo.processInfo.environment["FONTLIFT_OVERRIDE_USER_LIBRARY"]
private let overrideSystemLibraryPath = ProcessInfo.processInfo.environment["FONTLIFT_OVERRIDE_SYSTEM_LIBRARY"]
var fontManagerUnregisterFontsForURL: (CFURL, CTFontManagerScope, UnsafeMutablePointer<Unmanaged<CFError>?>?) -> Bool = CTFontManagerUnregisterFontsForURL

private struct ThirdPartyCacheSummary {
    let userRemoved: Int
    let systemRemoved: Int
    let warnings: [String]
}

private let adobeCacheRegex = try! NSRegularExpression(pattern: "^(Adobe|Acro|Illustrator)Fnt.*\\.lst$", options: .caseInsensitive)
private let officeCacheRegex = try! NSRegularExpression(pattern: "^Office Font Cache.*$", options: .caseInsensitive)

private func resolvedUserLibraryURL() -> URL {
    if let overrideUserLibraryPath, !overrideUserLibraryPath.isEmpty {
        return URL(fileURLWithPath: overrideUserLibraryPath, isDirectory: true)
    }
    return FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent("Library", isDirectory: true)
}

private func resolvedSystemLibraryURL() -> URL {
    if let overrideSystemLibraryPath, !overrideSystemLibraryPath.isEmpty {
        return URL(fileURLWithPath: overrideSystemLibraryPath, isDirectory: true)
    }
    return URL(fileURLWithPath: "/Library", isDirectory: true)
}

private func regexMatches(_ regex: NSRegularExpression, string: String) -> Bool {
    let range = NSRange(location: 0, length: (string as NSString).length)
    return regex.firstMatch(in: string, options: [], range: range) != nil
}

private struct FakeFontRegistry: Codable {
    private var fontsByName: [String: [String]] = [:]

    mutating func register(name: String, path: String) {
        var paths = fontsByName[name] ?? []
        if !paths.contains(path) {
            paths.append(path)
            fontsByName[name] = paths
        }
    }

    mutating func unregister(path: String) -> Bool {
        var removed = false
        for (name, var paths) in fontsByName {
            if let index = paths.firstIndex(of: path) {
                paths.remove(at: index)
                removed = true
                if paths.isEmpty {
                    fontsByName.removeValue(forKey: name)
                } else {
                    fontsByName[name] = paths
                }
                break
            }
        }
        return removed
    }

    func paths(for name: String) -> [String] {
        fontsByName[name] ?? []
    }

    func allPaths() -> [String] {
        fontsByName.values.flatMap { $0 }
    }
}

private var fakeFontRegistry = FakeFontRegistry()
private let fakeRegistryURL = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("fontlift-fake-registry.json")
private var isFakeRegistryLoaded = false
private func persistFakeRegistry() {
    guard fakeRegistrationMode else { return }
    ensureFakeRegistryLoaded()
    if let data = try? JSONEncoder().encode(fakeFontRegistry) {
        try? data.write(to: fakeRegistryURL, options: .atomic)
    }
}
private func ensureFakeRegistryLoaded(reload: Bool = false) {
    guard fakeRegistrationMode else { return }
    if !isFakeRegistryLoaded || reload {
        if FileManager.default.fileExists(atPath: fakeRegistryURL.path),
           let data = try? Data(contentsOf: fakeRegistryURL),
           let registry = try? JSONDecoder().decode(FakeFontRegistry.self, from: data) {
            fakeFontRegistry = registry
        }
        atexit {
            guard fakeRegistrationMode else { return }
            persistFakeRegistry()
        }
        isFakeRegistryLoaded = true
    }
}

// MARK: - Font Management Helpers

/// Escape a file path for safe use in shell commands
///
/// Wraps paths containing special characters in single quotes and escapes any single quotes within.
/// This ensures suggested shell commands (like "sudo fontlift-mac remove '/path/to/file'") work correctly
/// even when paths contain spaces, quotes, or other shell metacharacters.
///
/// - Parameter path: The file path to escape
/// - Returns: Shell-safe escaped path string
///
/// **Examples:**
/// - "~/Downloads/My Font.ttf" ‚Üí "'~/Downloads/My Font.ttf'"
/// - "/path/with'quote.ttf" ‚Üí "'/path/with'\''quote.ttf'"
/// - "/simple/path.ttf" ‚Üí "'/simple/path.ttf'"
func shellEscape(_ path: String) -> String {
    // Replace single quotes with '\'' (end quote, escaped quote, start quote)
    let escaped = path.replacingOccurrences(of: "'", with: "'\\''")
    return "'\(escaped)'"
}

/// Check if a font path is in a protected system directory
///
/// Prevents modification of system fonts that are critical for macOS stability.
/// System font directories include:
/// - `/System/Library/Fonts/` - Core macOS system fonts
/// - `/Library/Fonts/` - System-wide fonts (requires admin privileges)
///
/// - Parameter url: The font file URL to check
/// - Returns: `true` if the path is in a protected system directory; `false` otherwise
func isSystemFontPath(_ url: URL) -> Bool {
    let path = url.path
    return path.hasPrefix("/System/Library/Fonts/") || path.hasPrefix("/Library/Fonts/")
}

/// Validate that a file has a recognized font extension
///
/// Checks if the file extension matches known font formats supported by macOS Core Text.
/// This provides early validation before attempting font operations.
///
/// - Parameter path: The file path to validate
/// - Returns: `true` if the file has a valid font extension; `false` otherwise
///
/// Supported formats:
/// - .ttf (TrueType Font)
/// - .otf (OpenType Font)
/// - .ttc (TrueType Collection)
/// - .otc (OpenType Collection)
/// - .dfont (macOS Data Fork Font)
func isValidFontExtension(_ path: String) -> Bool {
    let validExtensions = ["ttf", "otf", "ttc", "otc", "dfont"]
    let pathExtension = (path as NSString).pathExtension.lowercased()
    return validExtensions.contains(pathExtension)
}

/// Validate that a file path exists, is readable, and is a regular file
///
/// Performs comprehensive validation before font operations to provide clear error messages.
/// This defensive check prevents cryptic Core Text errors by catching common mistakes early.
///
/// - Parameter path: The file path to validate (absolute or relative)
/// - Returns: `true` if the path is valid and readable; `false` if validation fails (with error printed to stdout)
///
/// **Validation checks performed:**
/// 1. File exists at the specified path
/// 2. Path points to a regular file (not a directory)
/// 3. File is readable by the current user
///
/// **Example:**
/// ```swift
/// guard validateFilePath("/path/to/font.ttf") else {
///     throw ExitCode.failure
/// }
/// ```
func validateFilePath(_ path: String) -> Bool {
    let fileManager = FileManager.default

    // Check if path exists
    guard fileManager.fileExists(atPath: path) else {
        print("‚ùå Error: File not found at path: \(path)")
        print("   Please check that the path is correct and the file exists")
        return false
    }

    // Check if it's a regular file (not a directory)
    var isDirectory: ObjCBool = false
    fileManager.fileExists(atPath: path, isDirectory: &isDirectory)
    guard !isDirectory.boolValue else {
        print("‚ùå Error: Path is a directory, not a file: \(path)")
        print("   Please specify a font file (.ttf, .otf, .ttc, .otc)")
        return false
    }

    // Check if file is readable
    guard fileManager.isReadableFile(atPath: path) else {
        print("‚ùå Error: File is not readable: \(path)")
        print("   Please check file permissions")
        return false
    }

    // Check if file has a valid font extension
    guard isValidFontExtension(path) else {
        print("‚ùå Error: Invalid font file format: \(path)")
        print("   Supported formats: .ttf, .otf, .ttc, .otc, .dfont")
        print("")
        print("   Common issues:")
        print("   - File is not a font file")
        print("   - File has wrong extension")
        print("   - File is corrupted or renamed")
        return false
    }

    return true
}

/// Get the PostScript name of a font from its file URL
///
/// Extracts the PostScript name using Core Graphics APIs. The PostScript name is the
/// technical identifier used internally by the font system (e.g., "Helvetica-Bold").
/// This is preferred over display names for font identification as it's more reliable.
///
/// **Core Text API Flow:**
/// 1. `CGDataProvider` - Creates a data provider from the font file URL
/// 2. `CGFont` - Parses the font file to create a font object
/// 3. `postScriptName` - Extracts the PostScript name property
///
/// - Parameter url: File URL pointing to a font file (.ttf, .otf, .ttc, .otc)
/// - Returns: PostScript name string if successful; `nil` if the file can't be read or parsed
///
/// **Example PostScript names:**
/// - "HelveticaNeue-Bold"
/// - "TimesNewRomanPS-BoldMT"
/// - "Arial-ItalicMT"
func getFontName(from url: URL) -> String? {
    guard let fontDataProvider = CGDataProvider(url: url as CFURL),
          let font = CGFont(fontDataProvider),
          let postScriptName = font.postScriptName as String? else {
        return nil
    }
    return postScriptName
}

/// Get the full font name (display name) from a URL
///
/// Extracts the human-readable display name using Core Text APIs. The full name is what users
/// see in font menus (e.g., "Helvetica Neue Bold"). This is used as a fallback when PostScript
/// names aren't available.
///
/// **Core Text API Flow:**
/// 1. `CTFontManagerCreateFontDescriptorsFromURL` - Creates font descriptors from file
/// 2. Uses first descriptor (font collections may contain multiple fonts)
/// 3. `CTFontCreateWithFontDescriptor` - Creates font object from descriptor
/// 4. `CTFontCopyFullName` - Extracts the full display name
///
/// - Parameter url: File URL pointing to a font file (.ttf, .otf, .ttc, .otc)
/// - Returns: Display name string if successful; `nil` if the file can't be read or has no display name
///
/// **Example display names:**
/// - "Helvetica Neue Bold"
/// - "Times New Roman Bold Italic"
/// - "Arial"
///
/// **Note:** For font collections (.ttc/.otc), this returns the name of the first font in the collection.
func getFullFontName(from url: URL) -> String? {
    guard let descriptors = CTFontManagerCreateFontDescriptorsFromURL(url as CFURL) as? [CTFontDescriptor],
          let descriptor = descriptors.first else {
        return nil
    }

    let font = CTFontCreateWithFontDescriptor(descriptor, 0, nil)
    return CTFontCopyFullName(font) as String?
}

/// Get the font family name from a URL
///
/// Extracts the human-readable family name (e.g., "Helvetica") using Core Text APIs.
/// This differs from the PostScript name which includes weight/style (e.g., "Helvetica-Bold").
///
/// - Parameter url: File URL pointing to a font file (.ttf, .otf, .ttc, .otc)
/// - Returns: Family name string if successful; `nil` otherwise
func getFontFamilyName(from url: URL) -> String? {
    guard let descriptors = CTFontManagerCreateFontDescriptorsFromURL(url as CFURL) as? [CTFontDescriptor],
          let descriptor = descriptors.first else {
        return nil
    }

    return CTFontDescriptorCopyAttribute(descriptor, kCTFontFamilyNameAttribute) as? String
}

/// Run a shell command and capture output/status.
///
/// Used for lightweight system maintenance commands (e.g., clearing font caches).
/// Returns combined stdout/stderr output trimmed of trailing whitespace.
///
/// - Parameter command: Command string executed via `/bin/zsh -c`
/// - Returns: Tuple of optional output string and process exit status
func shell(_ command: String) -> (String?, Int32) {
    let process = Process()
    process.executableURL = URL(fileURLWithPath: "/bin/zsh")
    process.arguments = ["-c", command]

    let stdoutPipe = Pipe()
    let stderrPipe = Pipe()
    process.standardOutput = stdoutPipe
    process.standardError = stderrPipe

    do {
        try process.run()
    } catch {
        return ("Failed to launch command: \(error.localizedDescription)", -1)
    }

    process.waitUntilExit()

    let stdoutData = stdoutPipe.fileHandleForReading.readDataToEndOfFile()
    let stderrData = stderrPipe.fileHandleForReading.readDataToEndOfFile()

    let stdout = String(data: stdoutData, encoding: .utf8)?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
    let stderr = String(data: stderrData, encoding: .utf8)?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""

    let combined = [stdout, stderr].filter { !$0.isEmpty }.joined(separator: "\n")
    return (combined.isEmpty ? nil : combined, process.terminationStatus)
}

/// Unregister a font from the system with shared safety checks.
///
/// - Parameters:
///   - url: Font file URL to unregister
///   - admin: When `true`, unregisters at `.session` scope (requires sudo). Otherwise `.user`.
///   - silent: When `true`, suppresses informational logging (still throws on failures).
/// - Throws: `ExitCode.failure` when unregistration is blocked or fails.
func unregisterFont(at url: URL, admin: Bool, silent: Bool = false) throws {
    if isSystemFontPath(url) {
        if !silent {
            print("‚ùå Error: Cannot uninstall system font.")
            print("   Path: \(url.path)")
            print("   System fonts in /System/Library/Fonts/ and /Library/Fonts/ are protected for macOS stability.")
            print("   Operations on these directories are blocked for safety.")
        }
        throw ExitCode.failure
    }

    if fakeRegistrationMode {
        ensureFakeRegistryLoaded()
        let removed = fakeFontRegistry.unregister(path: url.path)
        persistFakeRegistry()
        guard !silent else { return }

        let scopeDescription = "user-level and system-level (simulated)"
        if let fontName = getFontName(from: url) ?? getFullFontName(from: url) {
            if removed {
                print("‚úÖ [Simulated] Unregistered '\(fontName)' (\(scopeDescription))")
            } else {
                print("‚ÑπÔ∏è  [Simulated] No registration found for '\(fontName)' (\(scopeDescription))")
            }
        } else {
            if removed {
                print("‚úÖ [Simulated] Unregistered font at \(url.path) (\(scopeDescription))")
            } else {
                print("‚ÑπÔ∏è  [Simulated] No registration found at \(url.path) (\(scopeDescription))")
            }
        }
        return
    }

    func attemptUnregister(scope: CTFontManagerScope) -> (Bool, String?) {
        var error: Unmanaged<CFError>?
        let success = fontManagerUnregisterFontsForURL(url as CFURL, scope, &error)

        if success {
            return (true, nil)
        }

        if let error = error?.takeRetainedValue() {
            return (false, CFErrorCopyDescription(error) as String)
        }

        return (false, "Failed to unregister font due to unknown Core Text error.")
    }

    let (userSuccess, userError) = attemptUnregister(scope: .user)
    let (systemSuccess, systemError) = attemptUnregister(scope: .session)

    if userSuccess || systemSuccess {
        guard !silent else { return }

        let scopeDescription: String
        switch (userSuccess, systemSuccess) {
        case (true, true):
            scopeDescription = "user-level and system-level"
        case (true, false):
            scopeDescription = "user-level"
        case (false, true):
            scopeDescription = "system-level"
        case (false, false):
            scopeDescription = "unknown scope"
        }

        if let fontName = getFontName(from: url) ?? getFullFontName(from: url) {
            print("‚úÖ Successfully unregistered '\(fontName)' (\(scopeDescription))")
        } else {
            print("‚úÖ Successfully unregistered font at \(url.path) (\(scopeDescription))")
        }
        return
    }

    print("‚ùå Error: Unable to unregister font in user or system scope.")
    print("   File: \(url.path)")
    if let userError {
        print("   User scope: \(userError)")
    }
    if let systemError {
        print("   System scope: \(systemError)")
    }
    if geteuid() != 0 && !admin {
        print("   Tip: Try running with sudo and the --admin flag to remove system-level registrations.")
    }
    throw ExitCode.failure
}

/// Build formatted list output for the `list` command.
///
/// - Parameters:
///   - fontURLs: Font file URLs returned by Core Text.
///   - showPath: Include file paths in output.
///   - showName: Include font names in output.
///   - dedupeAll: When true, deduplicates all output lines. Paths are always deduplicated when shown alone.
/// - Returns: Sorted array of formatted output lines.
func buildListOutput(
    fontURLs: [URL],
    showPath: Bool,
    showName: Bool,
    dedupeAll: Bool
) -> [String] {
    var lines: [String] = []

    for fontURL in fontURLs {
        if showPath && showName {
            let fontName = getFontName(from: fontURL) ?? getFullFontName(from: fontURL) ?? "Unknown"
            lines.append("\(fontURL.path)::\(fontName)")
        } else if showPath {
            lines.append(fontURL.path)
        } else if let fontName = getFontName(from: fontURL) ?? getFullFontName(from: fontURL) {
            lines.append(fontName)
        }
    }

    let shouldDedupe = dedupeAll || (showPath && !showName)
    if shouldDedupe {
        lines = Array(Set(lines))
    }

    return lines.sorted()
}

@main
struct Fontlift: ParsableCommand {
    static let configuration = CommandConfiguration(
        commandName: binaryName,
        abstract: "Install, uninstall, list, and remove fonts on macOS",
        discussion: fontLabAttribution,
        version: "\(version) - \(fontLabAttribution)",
        subcommands: [
            List.self,
            Install.self,
            Uninstall.self,
            Remove.self,
            Cleanup.self
        ]
    )
}

// MARK: - List Command
extension Fontlift {
    /// List all installed fonts on the system
    ///
    /// This command enumerates fonts using `CTFontManagerCopyAvailableFontURLs()`,
    /// which returns fonts from system, user, and library directories.
    ///
    /// Behavior:
    /// - Output is always alphabetically sorted.
    /// - Path-only output is automatically deduplicated.
    /// - `-s` / `--sorted` additionally deduplicates name and `path::name` output.
    ///
    /// Output modes (all sorted):
    /// - Default (`-p`): Font file paths only (deduped)
    /// - Names (`-n`): Internal font names (may repeat without `-s`)
    /// - Both (`-p -n`): Combined format as `path::name` (deduped with `-s`)
    ///
    /// The output is pure data (no headers/footers) for pipe-friendly usage.
    ///
    /// Examples:
    /// ```bash
    /// fontlift-mac list              # Sorted, deduped font paths
    /// fontlift-mac list -n           # Sorted font names (dedupe with -s if needed)
    /// fontlift-mac list -p -n        # Sorted path::name pairs
    /// fontlift-mac list -n -s        # Sorted, deduped font names
    /// fontlift-mac list | wc -l      # Count total fonts
    /// fontlift-mac l                 # Same as 'list' (alias)
    /// ```
    ///
    /// Typical systems have 5000+ fonts installed.
    struct List: ParsableCommand {
        static let configuration = CommandConfiguration(
            commandName: "list",
            abstract: "List installed fonts",
            discussion: fontLabAttribution,
            aliases: ["l"]
        )

        @Flag(name: .shortAndLong, help: "Show font file paths")
        var path = false

        @Flag(name: .shortAndLong, help: "Show internal font names")
        var name = false

        @Flag(name: .shortAndLong, help: "Deduplicate names or path::name output (paths are deduped automatically)")
        var sorted = false

        func run() throws {
            // Default to showing paths if no flags specified
            // This provides backwards compatibility and sensible defaults
            let showPath = path || !name
            let showName = name

            // Query Core Text for all available font URLs in the system
            // This includes fonts from /System/Library/Fonts, /Library/Fonts, ~/Library/Fonts
            guard let fontURLs = CTFontManagerCopyAvailableFontURLs() as? [URL] else {
                print("‚ùå Error: Could not retrieve font list from system")
                print("   This may indicate a system font database issue")
                print("")
                print("   Troubleshooting:")
                print("   - Restart your Mac to rebuild font cache")
                print("   - Run: atsutil databases -remove")
                print("   - Check Console.app for system font errors")
                throw ExitCode.failure
            }

            let lines = buildListOutput(
                fontURLs: fontURLs,
                showPath: showPath,
                showName: showName,
                dedupeAll: sorted
            )

            // Output pure data only - no headers or footers
            for line in lines {
                print(line)
            }
        }
    }
}

// MARK: - Cleanup Command
extension Fontlift {
    /// Maintenance command to prune missing registrations and clear caches.
    struct Cleanup: ParsableCommand {
        static let configuration = CommandConfiguration(
            commandName: "cleanup",
            abstract: "Prune missing fonts and clear font caches",
            discussion: fontLabAttribution,
            aliases: ["c"]
        )

        @Flag(help: "Only prune missing font file registrations.")
        var pruneOnly = false

        @Flag(help: "Only clear font caches.")
        var cacheOnly = false

        @Flag(name: .shortAndLong, help: "Perform system-level cleanup (all users, requires sudo)")
        var admin = false

        func run() throws {
            let runBoth = (!pruneOnly && !cacheOnly) || (pruneOnly && cacheOnly)
            let doPrune = runBoth || pruneOnly
            let doCache = runBoth || cacheOnly
            let scopeDescription = admin ? "system-level (all users)" : "user-level (current user)"

            print("Scope: \(scopeDescription)")

            var hadErrors = false

            if doPrune {
                print("--- Pruning Missing Fonts ---")
                do {
                    try pruneMissingFonts(admin: admin)
                } catch {
                    hadErrors = true
                    print("‚ùå Pruning missing fonts failed.")
                }
                print("")
            }

            if doCache {
                print("--- Clearing Font Caches ---")
                do {
                    try clearFontCaches(admin: admin)
                } catch {
                    hadErrors = true
                    print("‚ùå Cache clearing failed.")
                }
                print("")
            }

            print("‚úÖ Cleanup complete.")
            if hadErrors {
                throw ExitCode.failure
            }
        }

        /// Scan all registered fonts and remove entries whose files are missing.
        private func pruneMissingFonts(admin: Bool) throws {
            print("Scanning for missing font registrations...")

            if fakeRegistrationMode {
                var registry = FakeFontRegistry()
                if let data = try? Data(contentsOf: fakeRegistryURL),
                   let decoded = try? JSONDecoder().decode(FakeFontRegistry.self, from: data) {
                    registry = decoded
                }

                let paths = registry.allPaths()
                var prunedCount = 0
                var checkedCount = 0

                for path in paths {
                    checkedCount += 1
                    if FileManager.default.fileExists(atPath: path) {
                        continue
                    }

                    print("üóëÔ∏è Pruning missing font registration: \(path)")
                    _ = registry.unregister(path: path)
                    prunedCount += 1
                }

                fakeFontRegistry = registry
                if let encoded = try? JSONEncoder().encode(registry) {
                    try? encoded.write(to: fakeRegistryURL, options: .atomic)
                }

                print("Scan complete. Checked \(checkedCount) fonts, pruned \(prunedCount) registrations.")
                return
            }

            guard let fontURLs = CTFontManagerCopyAvailableFontURLs() as? [URL] else {
                print("‚ùå Error: Could not retrieve font list from system.")
                throw ExitCode.failure
            }

            var prunedCount = 0
            var checkedCount = 0

            for url in fontURLs {
                checkedCount += 1

                if isSystemFontPath(url) {
                    continue
                }

                guard url.isFileURL else {
                    continue
                }

                if FileManager.default.fileExists(atPath: url.path) {
                    continue
                }

                print("üóëÔ∏è Pruning missing font registration: \(url.path)")

                if fakeRegistrationMode {
                    prunedCount += 1
                    continue
                }

                var userError: Unmanaged<CFError>?
                let userSuccess = CTFontManagerUnregisterFontsForURL(url as CFURL, .user, &userError)

                var sessionSuccess = false
                var sessionError: Unmanaged<CFError>?
                if admin {
                    sessionSuccess = CTFontManagerUnregisterFontsForURL(url as CFURL, .session, &sessionError)
                }

                if !userSuccess, let error = userError?.takeRetainedValue() {
                    let description = CFErrorCopyDescription(error) as String
                    print("   ‚ö†Ô∏è Unable to unregister user scope: \(description)")
                }

                if admin, !sessionSuccess, let error = sessionError?.takeRetainedValue() {
                    let description = CFErrorCopyDescription(error) as String
                    print("   ‚ö†Ô∏è Unable to unregister system scope: \(description)")
                }

                if userSuccess || (admin && sessionSuccess) {
                    prunedCount += 1
                } else {
                    print("   ‚ö†Ô∏è Font remains registered; manual intervention may be required.")
                }
            }

            print("Scan complete. Checked \(checkedCount) fonts, pruned \(prunedCount) registrations.")
        }

        /// Clear Core Text font caches via atsutil and purge third-party caches.
        private func clearFontCaches(admin: Bool) throws {
            let scopeLabel = admin ? "system" : "user"
            print("Clearing \(scopeLabel) font cache...")

            if fakeRegistrationMode {
                let message = admin ? "‚úÖ [Simulated] System font cache cleared successfully." : "‚úÖ [Simulated] User font cache cleared successfully."
                print(message)
            } else {
                if admin && geteuid() != 0 {
                    print("‚ùå Error: System-level cache clearing requires administrator privileges.")
                    print("   Run with sudo: sudo fontlift-mac cleanup --admin --cache-only")
                    throw ExitCode.failure
                }

                let command = admin ? "atsutil databases -remove" : "atsutil databases -removeUser"
                let (output, status) = shell(command)

                if status != 0 {
                    print("‚ùå Error: Failed to clear font cache (status \(status)).")
                    if let output {
                        print("   Details: \(output)")
                    }
                    throw ExitCode.failure
                }

                let successMessage = admin ? "‚úÖ System font cache cleared successfully." : "‚úÖ User font cache cleared successfully."
                print(successMessage)

                if admin {
                    let (_, shutdownStatus) = shell("atsutil server -shutdown")
                    if shutdownStatus != 0 {
                        print("   ‚ö†Ô∏è Warning: Unable to restart ATS server automatically. A reboot will rebuild caches.")
                    } else {
                        _ = shell("atsutil server -ping")
                    }
                }
            }

            print("   A logout or reboot may be required for changes to apply.")
            let summary = clearThirdPartyCaches(admin: admin)
            reportThirdPartySummary(summary, admin: admin)
        }

        private func clearThirdPartyCaches(admin: Bool) -> ThirdPartyCacheSummary {
            var warnings: [String] = []
            let userRemoved = removeThirdPartyCaches(in: resolvedUserLibraryURL(), scopeDescription: "user", warnings: &warnings)

            var systemRemoved = 0
            if admin {
                systemRemoved = removeThirdPartyCaches(in: resolvedSystemLibraryURL(), scopeDescription: "system", warnings: &warnings)
            }

            return ThirdPartyCacheSummary(userRemoved: userRemoved, systemRemoved: systemRemoved, warnings: warnings)
        }

        private func reportThirdPartySummary(_ summary: ThirdPartyCacheSummary, admin: Bool) {
            let totalRemoved = summary.userRemoved + summary.systemRemoved

            if totalRemoved == 0 {
                print("   No third-party font cache files were found.")
            } else if admin {
                print("   Removed \(summary.userRemoved) user and \(summary.systemRemoved) system third-party cache file(s) (Adobe, Microsoft).")
            } else {
                print("   Removed \(summary.userRemoved) third-party cache file(s) (Adobe, Microsoft).")
            }

            for warning in summary.warnings {
                print("   ‚ö†Ô∏è \(warning)")
            }
        }

        private func removeThirdPartyCaches(in library: URL, scopeDescription: String, warnings: inout [String]) -> Int {
            let fileManager = FileManager.default
            var removed = 0
            var localWarnings = warnings

            let directDirectories = [
                library.appendingPathComponent("Caches/com.adobe.fonts", isDirectory: true),
                library.appendingPathComponent("Caches/com.apple.iwork.fonts", isDirectory: true)
            ]

            for directory in directDirectories {
                if fileManager.fileExists(atPath: directory.path) {
                    do {
                        try fileManager.removeItem(at: directory)
                        removed += 1
                    } catch {
                        localWarnings.append("Failed to remove \(scopeDescription) cache at \(directory.path): \(error.localizedDescription)")
                    }
                }
            }

            let searchDirectories = [
                library.appendingPathComponent("Application Support/Adobe", isDirectory: true),
                library.appendingPathComponent("Caches/Adobe", isDirectory: true),
                library.appendingPathComponent("Preferences/Adobe", isDirectory: true),
                library.appendingPathComponent("Preferences/Microsoft", isDirectory: true)
            ]

            for directory in searchDirectories {
                guard fileManager.fileExists(atPath: directory.path) else {
                    continue
                }

                let enumerator = fileManager.enumerator(
                    at: directory,
                    includingPropertiesForKeys: [.isDirectoryKey],
                    options: [.skipsPackageDescendants, .skipsHiddenFiles],
                    errorHandler: { url, error -> Bool in
                        localWarnings.append("Failed to enumerate \(url.path) while clearing \(scopeDescription) caches: \(error.localizedDescription)")
                        return true
                    }
                )

                while let url = enumerator?.nextObject() as? URL {
                    let resourceValues: URLResourceValues
                    do {
                        resourceValues = try url.resourceValues(forKeys: [.isDirectoryKey])
                    } catch {
                        localWarnings.append("Failed to read attributes for \(url.path): \(error.localizedDescription)")
                        continue
                    }

                    if resourceValues.isDirectory == true {
                        continue
                    }

                    let name = url.lastPathComponent
                    let isAdobeCache = regexMatches(adobeCacheRegex, string: name)
                    let isOfficeCache = regexMatches(officeCacheRegex, string: name)

                    if isAdobeCache || isOfficeCache {
                        do {
                            try fileManager.removeItem(at: url)
                            removed += 1
                        } catch {
                            localWarnings.append("Failed to remove \(scopeDescription) cache file \(url.path): \(error.localizedDescription)")
                        }
                    }
                }
            }

            warnings = localWarnings
            return removed
        }
    }
}

// MARK: - Install Command
extension Fontlift {
    /// Install a font file to the system.
    ///
    /// Registers the font with macOS using `CTFontManagerRegisterFontsForURL()` at user scope
    /// (default) or system scope (with `--admin` flag).
    ///
    /// **User-level installation (default):**
    /// - Font available only to the current user
    /// - No administrator privileges required
    /// - Font registered at `.user` scope
    ///
    /// **System-level installation (--admin flag):**
    /// - Font available to all users in the current login session
    /// - Requires administrator privileges (run with `sudo`)
    /// - Font registered at `.session` scope
    ///
    /// The font file remains in its original location - this command only registers it with
    /// the system font manager. Use the remove command to both unregister and delete the file.
    ///
    /// Supports individual font files and font collections (.ttc/.otc).
    ///
    /// Example usage:
    /// ```bash
    /// fontlift-mac install ~/Downloads/CustomFont.ttf        # User-level
    /// fontlift-mac i /path/to/font.otf                       # User-level
    /// sudo fontlift-mac install --admin /path/to/font.ttf    # System-level (all users)
    /// sudo fontlift-mac i -a /path/to/font.ttf               # System-level (shorthand)
    /// ```
    struct Install: ParsableCommand {
        static let configuration = CommandConfiguration(
            commandName: "install",
            abstract: "Install fonts from file paths",
            discussion: fontLabAttribution,
            aliases: ["i"]
        )

        @Argument(help: "Font file path to install")
        var fontPath: String

        @Flag(name: .shortAndLong, help: "Install at system level (all users, requires sudo)")
        var admin = false

        func run() throws {
            // Validate file path before attempting installation
            guard validateFilePath(fontPath) else {
                throw ExitCode.failure
            }

            let url = URL(fileURLWithPath: fontPath)
            let scope: CTFontManagerScope = admin ? .session : .user
            let scopeDesc = admin ? "system-level (all users)" : "user-level"

            guard let newPostScriptName = getFontName(from: url) else {
                print("‚ùå Error: Could not read PostScript name from font file.")
                print("   File: \(fontPath)")
                print("   The file may be invalid or corrupted.")
                throw ExitCode.failure
            }

            let familyName = getFontFamilyName(from: url)

            print("Installing font from: \(fontPath)")
            print("Scope: \(scopeDesc)")
            if let familyName {
                print("PostScript: \(newPostScriptName) ‚Ä¢ Family: \(familyName)")
            } else {
                print("PostScript: \(newPostScriptName) ‚Ä¢ Family: Unknown")
            }

            // Attempt to find and remove conflicting registrations first
            if let existingFontURLs = CTFontManagerCopyAvailableFontURLs() as? [URL] {
                print("Checking for existing versions...")
                for existingURL in existingFontURLs {
                    if existingURL.path == url.path {
                        continue
                    }

                    guard let existingPostScript = getFontName(from: existingURL) else {
                        continue
                    }

                    if existingPostScript == newPostScriptName {
                        if isSystemFontPath(existingURL) {
                            print("‚ùå Error: Cannot replace protected system font.")
                            print("   Path: \(existingURL.path)")
                            print("   Installation aborted to prevent system instability.")
                            throw ExitCode.failure
                        }

                        print("Auto-uninstalling older version at: \(existingURL.path)")
                        do {
                            try unregisterFont(at: existingURL, admin: admin)
                        } catch {
                            print("‚ö†Ô∏è Warning: Unable to unregister older version at \(existingURL.path).")
                            print("   Proceeding with installation may leave duplicate registrations.")
                        }
                    }
                }
            } else {
                print("‚ö†Ô∏è Warning: Could not enumerate installed fonts. Skipping auto-uninstall check.")
            }

            if fakeRegistrationMode {
                ensureFakeRegistryLoaded()
                var existingPaths = fakeFontRegistry.paths(for: newPostScriptName).filter { $0 != url.path }
                if existingPaths.isEmpty {
                    existingPaths = fakeFontRegistry.allPaths().filter { candidatePath in
                        guard candidatePath != url.path else { return false }
                        let candidateURL = URL(fileURLWithPath: candidatePath)
                        return (getFontName(from: candidateURL) ?? getFullFontName(from: candidateURL)) == newPostScriptName
                    }
                }

                for path in existingPaths {
                    print("Auto-uninstalling older version at: \(path)")
                    do {
                        try unregisterFont(at: URL(fileURLWithPath: path), admin: admin)
                    } catch {
                        // In simulated mode, failures are already reported.
                    }
                }
                fakeFontRegistry.register(name: newPostScriptName, path: url.path)
                persistFakeRegistry()
                print("‚úÖ [Simulated] Installed: \(newPostScriptName)")
                return
            }

            var error: Unmanaged<CFError>?
            // Register font at .user scope (doesn't require sudo, available to current user only)
            // Or .session scope (requires sudo, available to all users in current login session)
            let success = CTFontManagerRegisterFontsForURL(url as CFURL, scope, &error)

            if success {
                if let fontName = getFontName(from: url) ?? getFullFontName(from: url) {
                    print("‚úÖ Successfully installed: \(fontName)")
                } else {
                    print("‚úÖ Successfully installed font")
                }
            } else {
                if let error = error?.takeRetainedValue() {
                    let errorDesc = CFErrorCopyDescription(error) as String

                    // Check if this is a duplicate registration error
                    if errorDesc.contains("already activated") || errorDesc.contains("already registered") {
                        if let fontName = getFontName(from: url) ?? getFullFontName(from: url) {
                            print("‚ÑπÔ∏è  Font already installed: \(fontName)")
                            print("   File: \(fontPath)")
                        } else {
                            print("‚ÑπÔ∏è  Font already installed")
                            print("   File: \(fontPath)")
                        }
                        print("")
                        print("   Use 'fontlift-mac list' to see all installed fonts")
                        print("   Use 'fontlift-mac uninstall' to remove before reinstalling")
                        throw ExitCode.failure
                    }

                    // Generic error handling for other failures
                    print("‚ùå Error installing font: \(errorDesc)")
                    print("   File: \(fontPath)")
                    print("")
                    print("   Common causes:")
                    print("   - Invalid or corrupted font file")
                    print("   - Font format not supported (.ttf, .otf, .ttc, .otc)")

                    if admin {
                        print("   - Permission denied (ensure you're running with sudo)")
                        print("   - System-level installation requires administrator privileges")
                    } else {
                        print("   - Permission issues (try with --admin flag and sudo for system-level install)")
                    }
                    throw ExitCode.failure
                } else {
                    print("‚ùå Error: Failed to install font")
                    print("   File: \(fontPath)")
                    throw ExitCode.failure
                }
            }
        }
    }
}

// MARK: - Uninstall Command
extension Fontlift {
    /// Uninstall a font from the system while keeping the file.
    ///
    /// Deregisters the font using `CTFontManagerUnregisterFontsForURL()` but leaves the
    /// font file in place. The font will no longer appear in applications' font pickers.
    ///
    /// **User-level uninstallation (default):**
    /// - Removes font registration for the current user only
    /// - No administrator privileges required
    /// - Font deregistered at `.user` scope
    ///
    /// **System-level uninstallation (--admin flag):**
    /// - Removes font registration for all users in the current login session
    /// - Requires administrator privileges (run with `sudo`)
    /// - Font deregistered at `.session` scope
    ///
    /// You can specify the font either by:
    /// - File path: `fontlift-mac uninstall /path/to/font.ttf`
    /// - Font name: `fontlift-mac uninstall -n "Arial"`
    ///
    /// When using `-n`, the command searches all installed fonts to find a matching name.
    /// If the font file no longer exists but is still registered, uninstall will attempt
    /// to deregister it anyway.
    ///
    /// Use the remove command if you want to both unregister and delete the file.
    ///
    /// Example usage:
    /// ```bash
    /// fontlift-mac uninstall ~/Downloads/CustomFont.ttf        # User-level
    /// fontlift-mac u -n "Helvetica Neue"                       # User-level
    /// sudo fontlift-mac uninstall --admin /path/to/font.ttf    # System-level (all users)
    /// sudo fontlift-mac u -a -n "Arial"                        # System-level (shorthand)
    /// ```
    struct Uninstall: ParsableCommand {
        static let configuration = CommandConfiguration(
            commandName: "uninstall",
            abstract: "Uninstall fonts (keeping files)",
            discussion: fontLabAttribution,
            aliases: ["u"]
        )

        @Option(name: .shortAndLong, help: "Font name to uninstall")
        var name: String?

        @Argument(help: "Font file path to uninstall")
        var fontPath: String?

        @Flag(name: .shortAndLong, help: "Uninstall at system level (all users, requires sudo)")
        var admin = false

        func validate() throws {
            if name == nil && fontPath == nil {
                throw ValidationError("Specify either --name or a font path")
            }
            if name != nil && fontPath != nil {
                throw ValidationError("Specify either --name or a font path, not both")
            }
        }

        func run() throws {
            if let fontName = name {
                // Find font by name
                print("Uninstalling font by name: \(fontName)")

                guard let fontURLs = CTFontManagerCopyAvailableFontURLs() as? [URL] else {
                    print("‚ùå Error: Could not retrieve font list from system")
                    print("   This may indicate a system font database issue")
                    print("")
                    print("   Troubleshooting:")
                    print("   - Restart your Mac to rebuild font cache")
                    print("   - Run: atsutil databases -remove")
                    print("   - Check Console.app for system font errors")
                    throw ExitCode.failure
                }

                var matchingURLs: [URL] = []
                for url in fontURLs {
                    if let urlFontName = getFontName(from: url) ?? getFullFontName(from: url),
                       urlFontName == fontName {
                        matchingURLs.append(url)
                    }
                }

                guard !matchingURLs.isEmpty else {
                    print("‚ùå Error: Font '\(fontName)' not found in installed fonts")
                    print("   Font name: \(fontName)")
                    print("")
                    print("   Suggestions:")
                    print("   - Use 'fontlift-mac list -n' to see all installed font names")
                    print("   - Check spelling and case (font names are case-sensitive)")
                    print("   - Font may have already been uninstalled")
                    throw ExitCode.failure
                }

                guard matchingURLs.count == 1 else {
                    print("‚ùå Error: Ambiguous font name '\(fontName)' matches \(matchingURLs.count) fonts")
                    print("")
                    print("   Matching fonts:")
                    for (index, url) in matchingURLs.enumerated() {
                        print("   \(index + 1). \(url.path)")
                        print("        fontlift-mac uninstall \(shellEscape(url.path))")
                    }
                    print("")
                    print("   Copy and run one of the commands above to uninstall the specific font.")
                    throw ExitCode.failure
                }

                let url = matchingURLs[0]

                let scopeDesc = admin ? "system-level (all users)" : "user-level"
                print("Scope: \(scopeDesc)")
                try unregisterFont(at: url, admin: admin)

            } else if let path = fontPath {
                let url = URL(fileURLWithPath: path)

                if !FileManager.default.fileExists(atPath: path) {
                    print("‚ö†Ô∏è  Warning: Font file not found at path: \(path)")
                    print("Attempting to uninstall anyway...")
                }

                print("Uninstalling font from path: \(path)")
                let scopeDesc = admin ? "system-level (all users)" : "user-level"
                print("Scope: \(scopeDesc)")
                try unregisterFont(at: url, admin: admin)
            }
        }
    }
}

// MARK: - Remove Command
extension Fontlift {
    /// Remove a font from the system and delete the file.
    ///
    /// This command performs two operations:
    /// 1. Deregisters the font from the system (like uninstall)
    /// 2. Deletes the font file from disk
    ///
    /// ‚ö†Ô∏è Warning: This is a destructive operation. The font file will be permanently deleted.
    ///
    /// **User-level removal (default):**
    /// - Removes font registration for the current user only
    /// - Deletes the font file (requires write permission to file)
    /// - No administrator privileges required for deregistration
    /// - Font deregistered at `.user` scope
    ///
    /// **System-level removal (--admin flag):**
    /// - Removes font registration for all users in the current login session
    /// - Deletes the font file (requires write permission to file)
    /// - Requires administrator privileges (run with `sudo`)
    /// - Font deregistered at `.session` scope
    ///
    /// You can specify the font either by:
    /// - File path: `fontlift-mac remove /path/to/font.ttf`
    /// - Font name: `fontlift-mac remove -n "Arial"`
    ///
    /// When using `-n`, the command searches all installed fonts to find the file location,
    /// then unregisters and deletes it.
    ///
    /// If unregistration fails, the command will still attempt to delete the file.
    /// Use uninstall if you only want to deregister without deleting.
    ///
    /// Example usage:
    /// ```bash
    /// fontlift-mac remove ~/Downloads/CustomFont.ttf        # User-level
    /// fontlift-mac rm -n "Helvetica Neue"                   # User-level
    /// sudo fontlift-mac remove --admin /path/to/font.ttf    # System-level (all users)
    /// sudo fontlift-mac rm -a -n "Arial"                    # System-level (shorthand)
    /// ```
    struct Remove: ParsableCommand {
        static let configuration = CommandConfiguration(
            commandName: "remove",
            abstract: "Remove fonts (uninstall and delete files)",
            discussion: fontLabAttribution,
            aliases: ["rm"]
        )

        @Option(name: .shortAndLong, help: "Font name to remove")
        var name: String?

        @Argument(help: "Font file path to remove")
        var fontPath: String?

        @Flag(name: .shortAndLong, help: "Remove at system level (all users, requires sudo)")
        var admin = false

        func validate() throws {
            if name == nil && fontPath == nil {
                throw ValidationError("Specify either --name or a font path")
            }
            if name != nil && fontPath != nil {
                throw ValidationError("Specify either --name or a font path, not both")
            }
        }

        func run() throws {
            if let fontName = name {
                // Find font by name
                print("Removing font by name: \(fontName)")

                guard let fontURLs = CTFontManagerCopyAvailableFontURLs() as? [URL] else {
                    print("‚ùå Error: Could not retrieve font list from system")
                    print("   This may indicate a system font database issue")
                    print("")
                    print("   Troubleshooting:")
                    print("   - Restart your Mac to rebuild font cache")
                    print("   - Run: atsutil databases -remove")
                    print("   - Check Console.app for system font errors")
                    throw ExitCode.failure
                }

                var matchingURLs: [URL] = []
                for url in fontURLs {
                    if let urlFontName = getFontName(from: url) ?? getFullFontName(from: url),
                       urlFontName == fontName {
                        matchingURLs.append(url)
                    }
                }

                guard !matchingURLs.isEmpty else {
                    print("‚ùå Error: Font '\(fontName)' not found in installed fonts")
                    print("   Font name: \(fontName)")
                    print("")
                    print("   Suggestions:")
                    print("   - Use 'fontlift-mac list -n' to see all installed font names")
                    print("   - Check spelling and case (font names are case-sensitive)")
                    print("   - Font may have already been removed")
                    throw ExitCode.failure
                }

                guard matchingURLs.count == 1 else {
                    print("‚ùå Error: Ambiguous font name '\(fontName)' matches \(matchingURLs.count) fonts")
                    print("")
                    print("   Matching fonts:")
                    for (index, url) in matchingURLs.enumerated() {
                        print("   \(index + 1). \(url.path)")
                        print("        fontlift-mac remove \(shellEscape(url.path))")
                    }
                    print("")
                    print("   Copy and run one of the commands above to remove the specific font.")
                    throw ExitCode.failure
                }

                let url = matchingURLs[0]

                try removeFont(at: url)

            } else if let path = fontPath {
                let url = URL(fileURLWithPath: path)

                guard FileManager.default.fileExists(atPath: path) else {
                    print("‚ùå Error: Font file not found at path: \(path)")
                    throw ExitCode.failure
                }

                print("Removing font from path: \(path)")
                try removeFont(at: url)
            }
        }

        private func removeFont(at url: URL) throws {
            // Protect system fonts from accidental modification
            if isSystemFontPath(url) {
                print("‚ùå Error: Cannot remove system font")
                print("   Path: \(url.path)")
                print("")
                print("   System fonts in /System/Library/Fonts/ and /Library/Fonts/")
                print("   are critical for macOS stability and cannot be removed.")
                print("")
                print("   If you need to manage a font, copy it to ~/Library/Fonts/ first.")
                throw ExitCode.failure
            }

            let scopeDesc = admin ? "system-level (all users)" : "user-level"
            print("Scope: \(scopeDesc)")

            // Get font name before deletion (file must exist to read metadata)
            let fontName = getFontName(from: url) ?? getFullFontName(from: url)

            do {
                try unregisterFont(at: url, admin: admin, silent: true)
            } catch {
                print("‚ö†Ô∏è  Warning: Font unregistration failed. Proceeding with file deletion.")
            }

            // Verify file still exists before deletion (race condition protection)
            guard FileManager.default.fileExists(atPath: url.path) else {
                print("‚ö†Ô∏è  Warning: Font file no longer exists at: \(url.path)")
                print("   File may have been removed by another process")
                print("   Font was unregistered successfully (if it was registered)")
                return
            }

            // Then delete the file
            do {
                try FileManager.default.removeItem(at: url)
                if let name = fontName {
                    print("‚úÖ Successfully removed: \(name)")
                } else {
                    print("‚úÖ Successfully removed font file: \(url.lastPathComponent)")
                }
            } catch let error as NSError {
                // Provide specific error guidance based on error type
                print("‚ùå Error deleting font file: \(error.localizedDescription)")
                print("   File: \(url.path)")
                print("")

                // Check for specific error codes to provide targeted guidance
                if error.domain == NSCocoaErrorDomain {
                    switch error.code {
                    case NSFileNoSuchFileError:
                        print("   File was removed by another process between validation and deletion")
                        print("   This is not an error - the file is already gone")
                        return  // Success - file is already deleted
                    case NSFileWriteNoPermissionError:
                        print("   Permission denied - you don't have write access to this file")
                        print("   Try running: sudo fontlift-mac remove \(shellEscape(url.path))")
                    case NSFileReadNoSuchFileError:
                        print("   Parent directory no longer exists")
                    default:
                        print("   Common causes:")
                        print("   - File is read-only or protected")

                        if admin {
                            print("   - Ensure you're running with sudo for system-level operations")
                        } else {
                            print("   - Permission denied (try with sudo)")
                        }

                        print("   - File is in use by another process")
                        print("   - File is in a protected system directory")
                    }
                }

                throw ExitCode.failure
            }
        }
    }
}
````

## TODO.md
```markdown
# TODO.md
<!-- this_file: TODO.md -->
```

## Tests/fontliftTests/CLIErrorTests.swift
```swift
// this_file: Tests/fontliftTests/CLIErrorTests.swift
// CLI error handling and command validation tests

import XCTest

final class CLIErrorTests: XCTestCase {

    // MARK: - Helper Methods

    /// Get project root directory
    func getProjectRoot() -> URL {
        let currentFile = URL(fileURLWithPath: #filePath)
        return currentFile
            .deletingLastPathComponent()  // Remove CLIErrorTests.swift
            .deletingLastPathComponent()  // Remove fontliftTests
            .deletingLastPathComponent()  // Remove Tests -> now at project root
    }

    /// Get path to debug binary for the CLI executable
    func getBinaryPath() -> String {
        let projectRoot = getProjectRoot()
        return projectRoot
            .appendingPathComponent(".build")
            .appendingPathComponent("debug")
            .appendingPathComponent("fontlift-mac")
            .path
    }

    /// Extract the declared version from the Swift source
    func getDeclaredVersion() throws -> String {
        let projectRoot = getProjectRoot()
        let mainFile = projectRoot
            .appendingPathComponent("Sources")
            .appendingPathComponent("fontlift")
            .appendingPathComponent("fontlift.swift")
        let contents = try String(contentsOf: mainFile, encoding: .utf8)
        let pattern = #"private let version = "([0-9]+\.[0-9]+\.[0-9]+)""#
        let regex = try NSRegularExpression(pattern: pattern)
        let range = NSRange(contents.startIndex..<contents.endIndex, in: contents)
        guard let match = regex.firstMatch(in: contents, range: range),
              let versionRange = Range(match.range(at: 1), in: contents) else {
            throw XCTSkip("Unable to parse version from fontlift.swift")
        }
        return String(contents[versionRange])
    }

    /// Run fontlift-mac binary and capture output
    func runFontlift(args: [String]) -> (exitCode: Int32, output: String, error: String) {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: getBinaryPath())
        process.arguments = args

        let outputPipe = Pipe()
        let errorPipe = Pipe()
        process.standardOutput = outputPipe
        process.standardError = errorPipe

        do {
            try process.run()
            process.waitUntilExit()

            let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
            let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()

            let output = String(data: outputData, encoding: .utf8) ?? ""
            let error = String(data: errorData, encoding: .utf8) ?? ""

            return (process.terminationStatus, output, error)
        } catch {
            XCTFail("Failed to run binary: \(error)")
            return (-1, "", "")
        }
    }

    // MARK: - Version Tests

    func testVersionFlag() throws {
        let expectedVersion = try getDeclaredVersion()
        let result = runFontlift(args: ["--version"])
        XCTAssertEqual(result.exitCode, 0, "Version flag should succeed")
        XCTAssertTrue(
            result.output.contains(expectedVersion),
            "Should show declared version \(expectedVersion)"
        )
    }

    func testVersionShowsFontLabAttribution() throws {
        let result = runFontlift(args: ["--version"])
        XCTAssertEqual(result.exitCode, 0, "Version flag should succeed")
        XCTAssertTrue(
            result.output.contains("made by FontLab https://www.fontlab.com/"),
            "Version output should include FontLab attribution"
        )
    }

    // MARK: - Help Tests

    func testHelpFlag() throws {
        let result = runFontlift(args: ["--help"])
        XCTAssertEqual(result.exitCode, 0, "Help flag should succeed")
        XCTAssertTrue(result.output.contains("USAGE"), "Help should show usage")
        XCTAssertTrue(result.output.contains("SUBCOMMANDS"), "Help should show subcommands")
    }

    func testHelpShowsFontLabAttribution() throws {
        let result = runFontlift(args: ["--help"])
        XCTAssertEqual(result.exitCode, 0, "Help flag should succeed")
        XCTAssertTrue(
            result.output.contains("made by FontLab https://www.fontlab.com/"),
            "Help should include FontLab attribution"
        )
    }

    func testListHelp() throws {
        let result = runFontlift(args: ["list", "--help"])
        XCTAssertEqual(result.exitCode, 0, "List help should succeed")
        XCTAssertTrue(result.output.contains("List installed fonts"), "Should show list description")
    }

    func testListHelpShowsFontLabAttribution() throws {
        let result = runFontlift(args: ["list", "--help"])
        XCTAssertEqual(result.exitCode, 0, "List help should succeed")
        XCTAssertTrue(
            result.output.contains("made by FontLab https://www.fontlab.com/"),
            "List help should include FontLab attribution"
        )
    }

    func testInstallHelp() throws {
        let result = runFontlift(args: ["install", "--help"])
        XCTAssertEqual(result.exitCode, 0, "Install help should succeed")
        XCTAssertTrue(result.output.contains("Install fonts"), "Should show install description")
    }

    func testUninstallHelp() throws {
        let result = runFontlift(args: ["uninstall", "--help"])
        XCTAssertEqual(result.exitCode, 0, "Uninstall help should succeed")
        XCTAssertTrue(result.output.contains("Uninstall fonts"), "Should show uninstall description")
    }

    func testRemoveHelp() throws {
        let result = runFontlift(args: ["remove", "--help"])
        XCTAssertEqual(result.exitCode, 0, "Remove help should succeed")
        XCTAssertTrue(result.output.contains("Remove fonts"), "Should show remove description")
    }

    // MARK: - Alias Tests

    func testListAlias() throws {
        let result = runFontlift(args: ["l", "--help"])
        XCTAssertEqual(result.exitCode, 0, "'l' alias should work")
        XCTAssertTrue(result.output.contains("List installed fonts"), "Should show list description")
    }

    func testInstallAlias() throws {
        let result = runFontlift(args: ["i", "--help"])
        XCTAssertEqual(result.exitCode, 0, "'i' alias should work")
        XCTAssertTrue(result.output.contains("Install fonts"), "Should show install description")
    }

    func testUninstallAlias() throws {
        let result = runFontlift(args: ["u", "--help"])
        XCTAssertEqual(result.exitCode, 0, "'u' alias should work")
        XCTAssertTrue(result.output.contains("Uninstall fonts"), "Should show uninstall description")
    }

    func testRemoveAlias() throws {
        let result = runFontlift(args: ["rm", "--help"])
        XCTAssertEqual(result.exitCode, 0, "'rm' alias should work")
        XCTAssertTrue(result.output.contains("Remove fonts"), "Should show remove description")
    }

    // MARK: - Error Tests

    func testInvalidSubcommand() throws {
        let result = runFontlift(args: ["invalid"])
        XCTAssertNotEqual(result.exitCode, 0, "Invalid subcommand should fail")
        XCTAssertTrue(result.error.contains("Error") || result.output.contains("Error"),
                     "Should show error message")
    }

    func testListWithoutArgs() throws {
        // Note: We test with --help instead of actually running list, because
        // list enumerates all 5000+ fonts which takes 15+ seconds and causes test timeouts
        let result = runFontlift(args: ["list", "--help"])
        XCTAssertEqual(result.exitCode, 0, "List command should show help")
        XCTAssertTrue(result.output.contains("List installed fonts"), "Should show list description")
    }

    func testInstallWithoutArgs() throws {
        let result = runFontlift(args: ["install"])
        XCTAssertNotEqual(result.exitCode, 0, "Install without path should fail")
        XCTAssertTrue(result.error.contains("Missing expected argument") ||
                     result.error.contains("Error"),
                     "Should show missing argument error")
    }

    func testUninstallWithoutArgs() throws {
        let result = runFontlift(args: ["uninstall"])
        XCTAssertNotEqual(result.exitCode, 0, "Uninstall without args should fail")
        XCTAssertTrue(result.error.contains("Specify either --name or a font path") ||
                     result.error.contains("Error"),
                     "Should show validation error")
    }

    func testRemoveWithoutArgs() throws {
        let result = runFontlift(args: ["remove"])
        XCTAssertNotEqual(result.exitCode, 0, "Remove without args should fail")
        XCTAssertTrue(result.error.contains("Specify either --name or a font path") ||
                     result.error.contains("Error"),
                     "Should show validation error")
    }

    func testUninstallWithBothNameAndPath() throws {
        let result = runFontlift(args: ["uninstall", "--name", "Arial", "/some/path.ttf"])
        XCTAssertNotEqual(result.exitCode, 0, "Uninstall with both args should fail")
        XCTAssertTrue(result.error.contains("Specify either --name or a font path, not both") ||
                     result.error.contains("Error"),
                     "Should show validation error about mutual exclusivity")
    }

    func testRemoveWithBothNameAndPath() throws {
        let result = runFontlift(args: ["remove", "--name", "Arial", "/some/path.ttf"])
        XCTAssertNotEqual(result.exitCode, 0, "Remove with both args should fail")
        XCTAssertTrue(result.error.contains("Specify either --name or a font path, not both") ||
                     result.error.contains("Error"),
                     "Should show validation error about mutual exclusivity")
    }

    // MARK: - System Font Protection Tests

    func testUninstallSystemFontProtection() throws {
        let result = runFontlift(args: ["uninstall", "/System/Library/Fonts/Helvetica.ttc"])
        XCTAssertNotEqual(result.exitCode, 0, "Uninstalling system font should fail")
        XCTAssertTrue(result.output.contains("Cannot uninstall system font") ||
                     result.output.contains("critical for macOS stability"),
                     "Should show system font protection error")
    }

    func testRemoveSystemFontProtection() throws {
        let result = runFontlift(args: ["remove", "/Library/Fonts/Arial Unicode.ttf"])
        XCTAssertNotEqual(result.exitCode, 0, "Removing system font should fail")
        XCTAssertTrue(result.output.contains("Cannot remove system font") ||
                     result.output.contains("critical for macOS stability"),
                     "Should show system font protection error")
    }

    // MARK: - Font Format Validation Tests

    func testInstallInvalidFileFormat() throws {
        let result = runFontlift(args: ["install", "/etc/hosts"])
        XCTAssertNotEqual(result.exitCode, 0, "Installing non-font file should fail")
        XCTAssertTrue(result.output.contains("Invalid font file format") ||
                     result.output.contains("Supported formats"),
                     "Should show invalid format error")
    }

    func testInstallTextFile() throws {
        let result = runFontlift(args: ["install", "/tmp/notafont.txt"])
        XCTAssertNotEqual(result.exitCode, 0, "Installing .txt file should fail")
        XCTAssertTrue(result.output.contains("Invalid font file format") ||
                     result.output.contains("File not found"),
                     "Should show format or file not found error")
    }

    // MARK: - Admin Flag Tests

    func testInstallHelpShowsAdminFlag() throws {
        let result = runFontlift(args: ["install", "--help"])
        XCTAssertEqual(result.exitCode, 0, "Install help should succeed")
        XCTAssertTrue(result.output.contains("--admin") || result.output.contains("-a"),
                     "Help should mention admin flag")
        XCTAssertTrue(result.output.contains("system level") || result.output.contains("all users"),
                     "Help should explain admin flag purpose")
    }

    func testUninstallHelpShowsAdminFlag() throws {
        let result = runFontlift(args: ["uninstall", "--help"])
        XCTAssertEqual(result.exitCode, 0, "Uninstall help should succeed")
        XCTAssertTrue(result.output.contains("--admin") || result.output.contains("-a"),
                     "Help should mention admin flag")
        XCTAssertTrue(result.output.contains("system level") || result.output.contains("all users"),
                     "Help should explain admin flag purpose")
    }

    func testRemoveHelpShowsAdminFlag() throws {
        let result = runFontlift(args: ["remove", "--help"])
        XCTAssertEqual(result.exitCode, 0, "Remove help should succeed")
        XCTAssertTrue(result.output.contains("--admin") || result.output.contains("-a"),
                     "Help should mention admin flag")
        XCTAssertTrue(result.output.contains("system level") || result.output.contains("all users"),
                     "Help should explain admin flag purpose")
    }

    func testInstallAdminFlagShortForm() throws {
        // Test that -a flag is accepted (will fail on file not found, not on flag)
        let result = runFontlift(args: ["install", "-a", "/tmp/nonexistent.ttf"])
        XCTAssertNotEqual(result.exitCode, 0, "Should fail on missing file")
        XCTAssertTrue(result.output.contains("File not found") ||
                     result.output.contains("Scope: system-level"),
                     "Should accept -a flag and show system-level scope or file not found")
    }

    func testInstallAdminFlagLongForm() throws {
        // Test that --admin flag is accepted (will fail on file not found, not on flag)
        let result = runFontlift(args: ["install", "--admin", "/tmp/nonexistent.ttf"])
        XCTAssertNotEqual(result.exitCode, 0, "Should fail on missing file")
        XCTAssertTrue(result.output.contains("File not found") ||
                     result.output.contains("Scope: system-level"),
                     "Should accept --admin flag and show system-level scope or file not found")
    }

    func testUninstallAdminFlagShortForm() throws {
        // Test that -a flag is accepted with uninstall
        let result = runFontlift(args: ["uninstall", "-a", "/tmp/nonexistent.ttf"])
        XCTAssertNotEqual(result.exitCode, 0, "Should fail on missing font")
        // The command should accept the flag without error about unknown flag
        XCTAssertFalse(result.error.contains("Unknown option") || result.error.contains("unexpected argument"),
                      "Should accept -a flag")
    }

    func testUninstallAdminFlagLongForm() throws {
        // Test that --admin flag is accepted with uninstall
        let result = runFontlift(args: ["uninstall", "--admin", "/tmp/nonexistent.ttf"])
        XCTAssertNotEqual(result.exitCode, 0, "Should fail on missing font")
        // The command should accept the flag without error about unknown flag
        XCTAssertFalse(result.error.contains("Unknown option") || result.error.contains("unexpected argument"),
                      "Should accept --admin flag")
    }

    func testRemoveAdminFlagShortForm() throws {
        // Test that -a flag is accepted with remove
        let result = runFontlift(args: ["remove", "-a", "/tmp/nonexistent.ttf"])
        XCTAssertNotEqual(result.exitCode, 0, "Should fail on missing file")
        XCTAssertTrue(result.output.contains("Font file not found") ||
                     result.output.contains("Scope: system-level"),
                     "Should accept -a flag")
    }

    func testRemoveAdminFlagLongForm() throws {
        // Test that --admin flag is accepted with remove
        let result = runFontlift(args: ["remove", "--admin", "/tmp/nonexistent.ttf"])
        XCTAssertNotEqual(result.exitCode, 0, "Should fail on missing file")
        XCTAssertTrue(result.output.contains("Font file not found") ||
                     result.output.contains("Scope: system-level"),
                     "Should accept --admin flag")
    }
}
```

## Tests/fontliftTests/HelperFunctionTests.swift
```swift
// this_file: Tests/fontliftTests/HelperFunctionTests.swift
// Unit tests for helper functions

import XCTest
import Foundation
@testable import fontlift

final class HelperFunctionTests: XCTestCase {

    // MARK: - shellEscape() Tests

    func testShellEscapeSimplePath() throws {
        let result = shellEscape("/path/to/font.ttf")
        XCTAssertEqual(result, "'/path/to/font.ttf'", "Simple paths should be wrapped in single quotes")
    }

    func testShellEscapePathWithSpaces() throws {
        let result = shellEscape("/path/to/My Font.ttf")
        XCTAssertEqual(result, "'/path/to/My Font.ttf'", "Paths with spaces should be wrapped in single quotes")
    }

    func testShellEscapePathWithSingleQuote() throws {
        let result = shellEscape("/path/to/user's font.ttf")
        XCTAssertEqual(result, "'/path/to/user'\\''s font.ttf'", "Single quotes should be escaped using '\\''")
    }

    func testShellEscapeEmptyPath() throws {
        let result = shellEscape("")
        XCTAssertEqual(result, "''", "Empty paths should result in empty quoted string")
    }

    // MARK: - isSystemFontPath() Tests

    func testIsSystemFontPathSystemLibrary() throws {
        let url = URL(fileURLWithPath: "/System/Library/Fonts/Helvetica.ttc")
        XCTAssertTrue(isSystemFontPath(url), "Paths in /System/Library/Fonts/ should be identified as system fonts")
    }

    func testIsSystemFontPathLibrary() throws {
        let url = URL(fileURLWithPath: "/Library/Fonts/Arial.ttf")
        XCTAssertTrue(isSystemFontPath(url), "Paths in /Library/Fonts/ should be identified as system fonts")
    }

    func testIsSystemFontPathUserLibrary() throws {
        let url = URL(fileURLWithPath: "/Users/test/Library/Fonts/Custom.ttf")
        XCTAssertFalse(isSystemFontPath(url), "User library fonts should NOT be identified as system fonts")
    }

    func testIsSystemFontPathHomeDirectory() throws {
        let url = URL(fileURLWithPath: "~/Library/Fonts/MyFont.ttf")
        XCTAssertFalse(isSystemFontPath(url), "Home directory fonts should NOT be identified as system fonts")
    }

    func testIsSystemFontPathRelative() throws {
        let url = URL(fileURLWithPath: "fonts/test.ttf")
        XCTAssertFalse(isSystemFontPath(url), "Relative paths should NOT be identified as system fonts")
    }

    // MARK: - isValidFontExtension() Tests

    func testIsValidFontExtensionTTF() throws {
        XCTAssertTrue(isValidFontExtension("/path/to/font.ttf"), ".ttf files should be valid")
        XCTAssertTrue(isValidFontExtension("/path/to/font.TTF"), ".TTF files should be valid (case-insensitive)")
    }

    func testIsValidFontExtensionOTF() throws {
        XCTAssertTrue(isValidFontExtension("/path/to/font.otf"), ".otf files should be valid")
        XCTAssertTrue(isValidFontExtension("/path/to/font.OTF"), ".OTF files should be valid (case-insensitive)")
    }

    func testIsValidFontExtensionTTC() throws {
        XCTAssertTrue(isValidFontExtension("/path/to/font.ttc"), ".ttc files should be valid")
    }

    func testIsValidFontExtensionOTC() throws {
        XCTAssertTrue(isValidFontExtension("/path/to/font.otc"), ".otc files should be valid")
    }

    func testIsValidFontExtensionDFont() throws {
        XCTAssertTrue(isValidFontExtension("/path/to/font.dfont"), ".dfont files should be valid")
    }

    func testIsValidFontExtensionInvalidExtensions() throws {
        XCTAssertFalse(isValidFontExtension("/path/to/file.txt"), ".txt files should be invalid")
        XCTAssertFalse(isValidFontExtension("/path/to/file.pdf"), ".pdf files should be invalid")
        XCTAssertFalse(isValidFontExtension("/path/to/file.zip"), ".zip files should be invalid")
        XCTAssertFalse(isValidFontExtension("/path/to/file"), "Files without extension should be invalid")
    }

    func testIsValidFontExtensionNoExtension() throws {
        XCTAssertFalse(isValidFontExtension("/path/to/fontfile"), "Paths without extension should be invalid")
    }
    // MARK: - getFontFamilyName() Tests

    func testGetFontFamilyNameReturnsFamilyForSystemFont() throws {
        let helveticaURL = URL(fileURLWithPath: "/System/Library/Fonts/Helvetica.ttc")
        let familyName = getFontFamilyName(from: helveticaURL)
        XCTAssertEqual(
            familyName,
            "Helvetica",
            "Should extract Helvetica family name from system font"
        )
    }

    func testGetFontFamilyNameReturnsNilForInvalidFile() throws {
        let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent("not-a-font.ttf")
        defer { try? FileManager.default.removeItem(at: tempURL) }
        try Data("not a real font".utf8).write(to: tempURL)

        let familyName = getFontFamilyName(from: tempURL)
        XCTAssertNil(familyName, "Invalid font file should return nil family name")
    }

    // MARK: - List Output Formatting

    func testListOutputIsSortedByDefaultForPaths() throws {
        let fontURLs = [
            URL(fileURLWithPath: "/Library/Fonts/Zeta.ttf"),
            URL(fileURLWithPath: "/Library/Fonts/Alpha.ttf"),
        ]

        let lines = buildListOutput(
            fontURLs: fontURLs,
            showPath: true,
            showName: false,
            dedupeAll: false
        )

        XCTAssertEqual(
            lines,
            ["/Library/Fonts/Alpha.ttf", "/Library/Fonts/Zeta.ttf"],
            "Path-only output should be alphabetically sorted by default"
        )
    }

    func testListOutputDedupesPathsByDefault() throws {
        let duplicatePath = "/Library/Fonts/Shared.ttf"
        let fontURLs = [
            URL(fileURLWithPath: duplicatePath),
            URL(fileURLWithPath: duplicatePath),
        ]

        let lines = buildListOutput(
            fontURLs: fontURLs,
            showPath: true,
            showName: false,
            dedupeAll: false
        )

        XCTAssertEqual(
            lines,
            [duplicatePath],
            "Path-only output should be deduplicated even without --sorted flag"
        )
    }

    func testListOutputDedupesWhenSortedFlagProvided() throws {
        let sharedPath = "/Library/Fonts/Shared.ttc"
        let fontURLs = [
            URL(fileURLWithPath: sharedPath),
            URL(fileURLWithPath: sharedPath),
        ]

        let lines = buildListOutput(
            fontURLs: fontURLs,
            showPath: true,
            showName: true,
            dedupeAll: true
        )

        XCTAssertEqual(
            lines,
            ["/Library/Fonts/Shared.ttc::Unknown"],
            "--sorted flag should deduplicate combined path::name output"
        )
    }
}
```

## Tests/fontliftTests/ProjectValidationTests.swift
```swift
// this_file: Tests/fontliftTests/ProjectValidationTests.swift
// Basic project validation tests

import XCTest

final class ProjectValidationTests: XCTestCase {

    // Helper to get project root
    func getProjectRoot() -> URL {
        // Start from current file's directory and navigate up
        // #file gives us Tests/fontliftTests/ProjectValidationTests.swift
        let currentFile = URL(fileURLWithPath: #filePath)
        // Go up to project root: remove /Tests/fontliftTests/ProjectValidationTests.swift
        return currentFile
            .deletingLastPathComponent()  // Remove ProjectValidationTests.swift
            .deletingLastPathComponent()  // Remove fontliftTests
            .deletingLastPathComponent()  // Remove Tests -> now at project root
    }

    func testPackageExists() throws {
        let packagePath = getProjectRoot().appendingPathComponent("Package.swift")
        XCTAssertTrue(
            FileManager.default.fileExists(atPath: packagePath.path),
            "Package.swift should exist at \(packagePath.path)"
        )
    }

    func testReadmeExists() throws {
        let readmePath = getProjectRoot().appendingPathComponent("README.md")
        XCTAssertTrue(
            FileManager.default.fileExists(atPath: readmePath.path),
            "README.md should exist at \(readmePath.path)"
        )
    }

    func testPrinciplesExists() throws {
        let principlesPath = getProjectRoot().appendingPathComponent("PRINCIPLES.md")
        XCTAssertTrue(
            FileManager.default.fileExists(atPath: principlesPath.path),
            "PRINCIPLES.md should exist (required by project principles)"
        )
    }

    func testBuildScriptExists() throws {
        let buildScript = getProjectRoot().appendingPathComponent("build.sh")
        XCTAssertTrue(
            FileManager.default.fileExists(atPath: buildScript.path),
            "build.sh should exist (required by PRINCIPLES.md)"
        )
        // Verify it's executable
        XCTAssertTrue(
            FileManager.default.isExecutableFile(atPath: buildScript.path),
            "build.sh should be executable"
        )
    }

    func testTestScriptExists() throws {
        let testScript = getProjectRoot().appendingPathComponent("test.sh")
        XCTAssertTrue(
            FileManager.default.fileExists(atPath: testScript.path),
            "test.sh should exist (required by development guidelines)"
        )
        XCTAssertTrue(
            FileManager.default.isExecutableFile(atPath: testScript.path),
            "test.sh should be executable"
        )
    }

    func testPublishScriptExists() throws {
        let publishScript = getProjectRoot().appendingPathComponent("publish.sh")
        XCTAssertTrue(
            FileManager.default.fileExists(atPath: publishScript.path),
            "publish.sh should exist (required by PRINCIPLES.md)"
        )
        XCTAssertTrue(
            FileManager.default.isExecutableFile(atPath: publishScript.path),
            "publish.sh should be executable"
        )
    }
}
```

## Tests/fontliftTests/UnregisterFontTests.swift
```swift
// this_file: Tests/fontliftTests/UnregisterFontTests.swift
// Tests for unregisterFont scope handling

import ArgumentParser
import CoreText
import Foundation
import XCTest
@testable import fontlift

final class UnregisterFontTests: XCTestCase {

    override func tearDown() {
        super.tearDown()
        fontManagerUnregisterFontsForURL = CTFontManagerUnregisterFontsForURL
    }

    func testUnregisterFontAttemptsUserAndSystemScopes() throws {
        var scopesAttempted: [CTFontManagerScope] = []
        fontManagerUnregisterFontsForURL = { _, scope, _ in
            scopesAttempted.append(scope)
            return scope == .session
        }

        let url = URL(fileURLWithPath: "/Users/test/Library/Fonts/Example.ttf")

        try unregisterFont(at: url, admin: false, silent: true)

        XCTAssertEqual(scopesAttempted, [.user, .session], "Should attempt both user and system scopes")
    }

    func testUnregisterFontFailsWhenBothScopesFail() throws {
        fontManagerUnregisterFontsForURL = { _, _, _ in false }

        let url = URL(fileURLWithPath: "/Users/test/Library/Fonts/Fail.ttf")

        XCTAssertThrowsError(try unregisterFont(at: url, admin: false, silent: true)) { error in
            XCTAssertEqual(error as? ExitCode, ExitCode.failure, "Should throw failure when all scopes fail")
        }
    }
}
```

## Tests/integration_test.sh
```bash
#!/bin/bash
# this_file: Tests/integration_test.sh
# Integration smoke tests for fontlift-mac binary
# Tests end-to-end functionality with real operations

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Test counters
TESTS_RUN=0
TESTS_PASSED=0
TESTS_FAILED=0

# Change to project root
cd "$(dirname "$0")/.."

echo "üß™ Running integration smoke tests..."
echo ""

# Ensure binary exists
if [ ! -f ".build/release/fontlift-mac" ]; then
    echo -e "${RED}‚ùå Binary not found at .build/release/fontlift-mac${NC}"
    echo "Run ./build.sh first"
    exit 1
fi

BINARY=".build/release/fontlift-mac"
export FONTLIFT_FAKE_REGISTRATION=1

# Helper function to run a test
run_test() {
    local test_name="$1"
    local command="$2"

    TESTS_RUN=$((TESTS_RUN + 1))

    if eval "$command" > /dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ${NC} $test_name"
        TESTS_PASSED=$((TESTS_PASSED + 1))
        return 0
    else
        echo -e "${RED}‚ùå${NC} $test_name"
        TESTS_FAILED=$((TESTS_FAILED + 1))
        return 1
    fi
}

# Test 1: Binary metadata and performance
echo "Testing binary metadata..."
run_test "Binary is executable" "[ -x $BINARY ]"
run_test "Binary size >1MB (universal)" "[ $(stat -f%z $BINARY) -gt 1048576 ]"
run_test "Binary --version outputs version" "$BINARY --version | grep -q '^[0-9]'"
run_test "Binary --help shows usage" "$BINARY --help | grep -q 'USAGE:'"

# Performance baselines (for regression detection)
echo ""
echo "Performance baselines:"
START_TIME=$(python3 -c 'import time; print(int(time.time() * 1000))')
$BINARY --version > /dev/null
END_TIME=$(python3 -c 'import time; print(int(time.time() * 1000))')
STARTUP_MS=$((END_TIME - START_TIME))
echo "  ‚Ä¢ Binary startup (--version): ${STARTUP_MS}ms"

START_TIME=$(python3 -c 'import time; print(int(time.time() * 1000))')
$BINARY list > /dev/null
END_TIME=$(python3 -c 'import time; print(int(time.time() * 1000))')
LIST_MS=$((END_TIME - START_TIME))
echo "  ‚Ä¢ List command execution: ${LIST_MS}ms"

# Validate performance is reasonable (<1s for each operation)
run_test "Startup time <1000ms" "[ $STARTUP_MS -lt 1000 ]"
run_test "List command <1000ms" "[ $LIST_MS -lt 1000 ]"
echo ""

# Test 2: List command (non-destructive)
echo "Testing list command..."
run_test "List command works" "$BINARY list | wc -l | grep -q '[0-9]'"
run_test "List -n works" "$BINARY list -n | wc -l | grep -q '[0-9]'"
run_test "List -p works" "$BINARY list -p | wc -l | grep -q '[0-9]'"
run_test "List -s reduces output" "[ $($BINARY list -n | wc -l) -gt $($BINARY list -n -s | wc -l) ]"
run_test "List -p -n uses :: separator" "($BINARY list -p -n 2>&1 || true) | head -1 | grep -q '::'"
run_test "List -n -p uses :: separator" "($BINARY list -n -p 2>&1 || true) | head -1 | grep -q '::'"
run_test "List -p does NOT use :: separator" "! (($BINARY list -p 2>&1 || true) | head -1 | grep -q '::')"
run_test "List -n does NOT use :: separator" "! (($BINARY list -n 2>&1 || true) | head -1 | grep -q '::')"
run_test "List output is sorted" "$BINARY list | sort -c"
run_test "List path output is deduplicated" "[ $($BINARY list | wc -l) -eq $($BINARY list | uniq | wc -l) ]"
echo ""

# Test 3: Help texts for all commands
echo "Testing command help texts..."
run_test "Install help" "$BINARY install --help | grep -q 'Install fonts'"
run_test "Uninstall help" "$BINARY uninstall --help | grep -q 'Uninstall fonts'"
run_test "Remove help" "$BINARY remove --help | grep -q 'Remove fonts'"
echo ""

# Test 4: Error handling
echo "Testing error handling..."
run_test "Install nonexistent file fails" "! $BINARY install /nonexistent/font.ttf 2>&1 | grep -q 'File not found'"
run_test "Uninstall nonexistent font fails" "! $BINARY uninstall -n NonExistentFont12345 2>&1 | grep -q 'not found'"
run_test "Install without args fails" "! $BINARY install 2>&1"
run_test "Uninstall without args fails" "! $BINARY uninstall 2>&1"
echo ""

# Test 5: Install auto-uninstall upgrades
echo "Testing install auto-uninstall..."
TESTDATA_DIR="$(pwd)/testdata"
TEST_FONT_V1="$TESTDATA_DIR/TestFont-v1.ttf"
TEST_FONT_V2="$TESTDATA_DIR/TestFont-v2.ttf"
TEST_FONT_V1_NAME="$(basename "$TEST_FONT_V1")"
TEST_FONT_V2_NAME="$(basename "$TEST_FONT_V2")"
SYSTEM_FONT="/System/Library/Fonts/Helvetica.ttc"
FAKE_REGISTRY_FILE=$(python3 - <<'PY'
import tempfile, os
print(os.path.join(tempfile.gettempdir(), "fontlift-fake-registry.json"))
PY
)

if [ ! -f "$TEST_FONT_V1" ] || [ ! -f "$TEST_FONT_V2" ]; then
    echo -e "${RED}‚ùå Test fonts not found in $TESTDATA_DIR${NC}"
    echo "Ensure TestFont-v1.ttf and TestFont-v2.ttf exist."
    exit 1
fi

if [ ! -f "$SYSTEM_FONT" ]; then
    echo -e "${RED}‚ùå Required system font not found: $SYSTEM_FONT${NC}"
    exit 1
fi

cleanup_auto_install() {
    $BINARY uninstall "$TEST_FONT_V1" 2>/dev/null || true
    $BINARY uninstall "$TEST_FONT_V2" 2>/dev/null || true
    rm -f /tmp/fontlift-auto-log.txt "$FAKE_REGISTRY_FILE"
}
trap cleanup_auto_install EXIT
cleanup_auto_install

run_test "Install v1 font succeeds" "$BINARY install $TEST_FONT_V1 | grep -q 'Installed'"
run_test "Install v2 font succeeds" "$BINARY install $TEST_FONT_V2 | grep -q 'Installed'"
run_test "Installing v2 removes previous v1 registration" \
    "! grep -q 'TestFont-v1.ttf' \"$FAKE_REGISTRY_FILE\""
run_test "Reinstalling v1 succeeds" "$BINARY install $TEST_FONT_V1 | grep -q 'Installed'"
run_test "Reinstalling v1 removes v2 registration" \
    "! grep -q 'TestFont-v2.ttf' \"$FAKE_REGISTRY_FILE\""
run_test "Reinstalling v2 succeeds" "$BINARY install $TEST_FONT_V2 | grep -q 'Installed'"
run_test "Reinstalling v2 removes v1 registration again" \
    "! grep -q 'TestFont-v1.ttf' \"$FAKE_REGISTRY_FILE\""
run_test "Installing conflict with system font blocked" \
    "! $BINARY install $SYSTEM_FONT 2>&1 | grep -q 'protected system font'"

# Test 6: Cleanup command
echo ""
echo "Testing cleanup command..."
cleanup_auto_install
CLEANUP_DIR=$(mktemp -d /tmp/fontlift-clean-XXXX)
PRUNE_FONT="$CLEANUP_DIR/font-to-prune.ttf"
USER_LIBRARY="$CLEANUP_DIR/UserLibrary"
SYSTEM_LIBRARY="$CLEANUP_DIR/SystemLibrary"
export FONTLIFT_OVERRIDE_USER_LIBRARY="$USER_LIBRARY"
export FONTLIFT_OVERRIDE_SYSTEM_LIBRARY="$SYSTEM_LIBRARY"

setup_third_party_caches() {
    rm -rf "$USER_LIBRARY" "$SYSTEM_LIBRARY"

    mkdir -p "$USER_LIBRARY/Application Support/Adobe/TypeSupport"
    mkdir -p "$USER_LIBRARY/Caches/Adobe/TypeSupport"
    mkdir -p "$USER_LIBRARY/Preferences/Microsoft"

    mkdir -p "$SYSTEM_LIBRARY/Application Support/Adobe/TypeSupport"
    mkdir -p "$SYSTEM_LIBRARY/Preferences/Microsoft"

    touch "$USER_LIBRARY/Application Support/Adobe/TypeSupport/AdobeFnt.lst"
    touch "$USER_LIBRARY/Caches/Adobe/TypeSupport/AdobeFnt16.lst"
    touch "$USER_LIBRARY/Preferences/Microsoft/Office Font Cache (16)"

    touch "$SYSTEM_LIBRARY/Application Support/Adobe/TypeSupport/AdobeFntSystem.lst"
    touch "$SYSTEM_LIBRARY/Preferences/Microsoft/Office Font Cache (16)"
}

setup_third_party_caches

cp "$TEST_FONT_V1" "$PRUNE_FONT"

run_test "Setup font for pruning installs successfully" "$BINARY install $PRUNE_FONT"
rm "$PRUNE_FONT"
run_test "Cleanup prune removes missing font registrations" \
    "$BINARY cleanup --prune-only 2>&1 | grep -q 'Pruning missing font'"
run_test "List output no longer includes pruned font" "! $BINARY list -p | grep -q \"$PRUNE_FONT\""
run_test "Cache clearing reports success" "$BINARY cleanup --cache-only 2>&1 | grep -q 'font cache cleared'"
run_test "User-level cleanup removes Adobe caches" \
    "[ ! -f \"$USER_LIBRARY/Application Support/Adobe/TypeSupport/AdobeFnt.lst\" ]"
run_test "User-level cleanup removes Microsoft caches" \
    "[ ! -f \"$USER_LIBRARY/Preferences/Microsoft/Office Font Cache (16)\" ]"
run_test "User-level cleanup leaves system caches intact" \
    "[ -f \"$SYSTEM_LIBRARY/Application Support/Adobe/TypeSupport/AdobeFntSystem.lst\" ]"

setup_third_party_caches

run_test "Admin cleanup clears caches without error" \
    "$BINARY cleanup --cache-only --admin 2>&1 | grep -q 'font cache cleared'"
run_test "Admin cleanup removes system Adobe caches" \
    "[ ! -f \"$SYSTEM_LIBRARY/Application Support/Adobe/TypeSupport/AdobeFntSystem.lst\" ]"
run_test "Admin cleanup removes system Microsoft caches" \
    "[ ! -f \"$SYSTEM_LIBRARY/Preferences/Microsoft/Office Font Cache (16)\" ]"
run_test "Cleanup alias help available" "$BINARY c --help | grep -q 'Prune missing fonts'"
echo ""
rm -rf "$CLEANUP_DIR"
unset FONTLIFT_OVERRIDE_USER_LIBRARY
unset FONTLIFT_OVERRIDE_SYSTEM_LIBRARY

# Test 7: Version extraction and consistency
echo "Testing version extraction..."
EXTRACTED_VERSION=$(./scripts/get-version.sh)
BINARY_VERSION=$($BINARY --version | awk '{print $1}')

# Test extracted version is valid semver (X.Y.Z format)
run_test "get-version.sh outputs valid semver" "echo '$EXTRACTED_VERSION' | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'"

# Test extracted version matches binary version
run_test "Extracted version matches binary" "[ '$EXTRACTED_VERSION' = '$BINARY_VERSION' ]"

# Test get-version.sh script exists and is executable
run_test "get-version.sh script exists" "[ -f ./scripts/get-version.sh ]"
run_test "get-version.sh is executable" "[ -x ./scripts/get-version.sh ]"
echo ""

# Print summary
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "Integration Test Summary:"
echo "  Total:  $TESTS_RUN"
echo -e "  ${GREEN}Passed: $TESTS_PASSED${NC}"
if [ $TESTS_FAILED -gt 0 ]; then
    echo -e "  ${RED}Failed: $TESTS_FAILED${NC}"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    exit 1
else
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo -e "${GREEN}‚úÖ All integration tests passed!${NC}"
    exit 0
fi
```

## Tests/scripts_test.sh
```bash
#!/bin/bash
# this_file: Tests/scripts_test.sh
# Test suite for all bash scripts in the project
# Usage: ./tests/scripts_test.sh

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Test counters
TESTS_RUN=0
TESTS_PASSED=0
TESTS_FAILED=0

# Change to project root
cd "$(dirname "$0")/.."

echo "üß™ Running scripts test suite..."
echo ""

# Helper function to run a test
run_test() {
    local test_name="$1"
    local command="$2"

    TESTS_RUN=$((TESTS_RUN + 1))

    if eval "$command" > /dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ${NC} $test_name"
        TESTS_PASSED=$((TESTS_PASSED + 1))
        return 0
    else
        echo -e "${RED}‚ùå${NC} $test_name"
        TESTS_FAILED=$((TESTS_FAILED + 1))
        return 1
    fi
}

# Test build.sh
echo "Testing build.sh..."
run_test "build.sh --help shows help" "./build.sh --help | grep -q 'Usage:'"
run_test "build.sh --ci builds successfully" "./build.sh --ci"
run_test "build.sh rejects invalid option" "! ./build.sh --invalid-option 2>&1 | grep -q 'Error:'"
run_test "build.sh produces binary" "[ -f .build/release/fontlift-mac ]"
run_test "build.sh binary is executable" "[ -x .build/release/fontlift-mac ]"
echo ""

# Test test.sh
echo "Testing test.sh..."
run_test "test.sh --help shows help" "./test.sh --help | grep -q 'Usage:'"
run_test "test.sh --ci runs tests" "SKIP_SCRIPT_TESTS=true ./test.sh --ci"
run_test "test.sh rejects invalid option" "! ./test.sh --invalid-option 2>&1 | grep -q 'Error:'"
echo ""

# Test publish.sh
echo "Testing publish.sh..."
run_test "publish.sh --help shows help" "./publish.sh --help | grep -q 'Usage:'"
run_test "publish.sh --ci verifies binary" "./publish.sh --ci"
run_test "publish.sh rejects invalid option" "! ./publish.sh --invalid-option 2>&1 | grep -q 'Error:'"
echo ""

# Test validate-version.sh
echo "Testing validate-version.sh..."
run_test "validate-version.sh --help shows help" "./scripts/validate-version.sh --help | grep -q 'Usage:'"
run_test "validate-version.sh matches current version" "./scripts/validate-version.sh $(./scripts/get-version.sh)"
run_test "validate-version.sh rejects invalid semver" "! ./scripts/validate-version.sh 1.1 2>&1"
run_test "validate-version.sh requires argument" "! ./scripts/validate-version.sh 2>&1"
echo ""

# Test get-version.sh
echo "Testing get-version.sh..."
run_test "get-version.sh extracts version" "./scripts/get-version.sh | grep -q '^[0-9]\\+\\.[0-9]\\+\\.[0-9]\\+$'"
# Dynamically extract version from code to avoid hardcoding
CODE_VERSION=$(grep "private let version = " Sources/fontlift/fontlift.swift | sed "s/.*\"\(.*\)\".*/\1/")
run_test "get-version.sh matches code" "[ \"$(./scripts/get-version.sh)\" = \"${CODE_VERSION}\" ]"
echo ""

# Test fontlift-mac binary
echo "Testing fontlift-mac binary..."
run_test "fontlift-mac --version works" ".build/release/fontlift-mac --version | grep -q '^[0-9]'"
run_test "fontlift-mac --help works" ".build/release/fontlift-mac --help | grep -q 'USAGE:'"
run_test "fontlift-mac list --help works" ".build/release/fontlift-mac list --help | grep -q 'List installed fonts'"
run_test "fontlift-mac install --help works" ".build/release/fontlift-mac install --help | grep -q 'Install fonts'"
run_test "fontlift-mac uninstall --help works" ".build/release/fontlift-mac uninstall --help | grep -q 'Uninstall fonts'"
run_test "fontlift-mac remove --help works" ".build/release/fontlift-mac remove --help | grep -q 'Remove fonts'"
echo ""

# Print summary
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "Test Summary:"
echo "  Total:  $TESTS_RUN"
echo -e "  ${GREEN}Passed: $TESTS_PASSED${NC}"
if [ $TESTS_FAILED -gt 0 ]; then
    echo -e "  ${RED}Failed: $TESTS_FAILED${NC}"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    exit 1
else
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo -e "${GREEN}‚úÖ All scripts tests passed!${NC}"
    exit 0
fi
```

## build.sh
```bash
#!/bin/bash
# this_file: build.sh
# Build fontlift-mac in release mode
#
# Usage: ./build.sh [OPTIONS]
#
# Options:
#   --ci          CI mode (minimal output)
#   --release   Build release binary (Intel + Apple Silicon)
#   --help        Show this help message

set -euo pipefail  # Exit on error, undefined vars, pipe failures
cd "$(dirname "$0")"

# Function to display help
show_help() {
    cat << EOF
Usage: $0 [OPTIONS]

Build fontlift-mac in release mode.

Options:
  --ci          CI mode (minimal output)
  --release   Build release binary (Intel + Apple Silicon)
  --help        Show this help message

Examples:
  $0                # Build for current architecture
  $0 --release    # Build release binary (both architectures)
  $0 --ci           # Build in CI mode
  CI=true $0        # Build in CI mode (environment variable)

Environment:
  CI                  Set to "true" to enable CI mode
  UNIVERSAL_BUILD     Set to "true" to build release binary
EOF
}

# Parse arguments
CI_MODE=false
UNIVERSAL_BUILD=false

if [[ "${CI:-}" == "true" ]]; then
    CI_MODE=true
fi

if [[ "${UNIVERSAL_BUILD:-}" == "true" ]]; then
    UNIVERSAL_BUILD=true
fi

for arg in "$@"; do
    case $arg in
        --ci)
            CI_MODE=true
            ;;
        --release)
            UNIVERSAL_BUILD=true
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        *)
            echo "‚ùå Error: Unknown option: $arg"
            echo ""
            show_help
            exit 1
            ;;
    esac
done

# Verify Swift version ‚â•5.9
REQUIRED_SWIFT_VERSION="5.9"
SWIFT_VERSION=$(swift --version 2>&1 | head -n 1 | grep -oE 'Swift version [0-9]+\.[0-9]+' | grep -oE '[0-9]+\.[0-9]+' | head -n 1)

if [ -z "$SWIFT_VERSION" ]; then
    echo "‚ùå Error: Failed to detect Swift version"
    echo ""
    echo "Please ensure Swift is installed and in your PATH."
    echo "Run: swift --version"
    exit 1
fi

# Compare versions (supports X.Y format)
REQUIRED_MAJOR=$(echo "$REQUIRED_SWIFT_VERSION" | cut -d. -f1)
REQUIRED_MINOR=$(echo "$REQUIRED_SWIFT_VERSION" | cut -d. -f2)
CURRENT_MAJOR=$(echo "$SWIFT_VERSION" | cut -d. -f1)
CURRENT_MINOR=$(echo "$SWIFT_VERSION" | cut -d. -f2)

if [ "$CURRENT_MAJOR" -lt "$REQUIRED_MAJOR" ] || \
   ([ "$CURRENT_MAJOR" -eq "$REQUIRED_MAJOR" ] && [ "$CURRENT_MINOR" -lt "$REQUIRED_MINOR" ]); then
    echo "‚ùå Error: Swift version $REQUIRED_SWIFT_VERSION or later is required"
    echo ""
    echo "Current version: Swift $SWIFT_VERSION"
    echo "Required version: Swift $REQUIRED_SWIFT_VERSION+"
    echo ""
    echo "Common causes:"
    echo "  ‚Ä¢ Xcode version is too old (requires Xcode 15.0+)"
    echo "  ‚Ä¢ Using outdated system Swift instead of Xcode's Swift"
    echo ""
    echo "Solutions:"
    echo "  1. Update Xcode from the Mac App Store"
    echo "  2. Select correct Xcode: sudo xcode-select -s /Applications/Xcode.app"
    echo "  3. Download Swift from https://swift.org/download/"
    echo "  4. Check installed version: swift --version"
    exit 1
fi

if [ "$UNIVERSAL_BUILD" = true ]; then
    # Build release binary (Intel + Apple Silicon)
    if [ "$CI_MODE" = false ]; then
        echo "üî® Building release binary (x86_64 + arm64)..."
        echo ""
    fi

    # Build for x86_64 (Intel)
    if [ "$CI_MODE" = false ]; then
        echo "üì¶ Phase 1/3: Building for x86_64 (Intel)..."
    fi

    if ! swift build -c release --arch x86_64; then
        echo "‚ùå Error: Failed to build for x86_64"
        exit 1
    fi

    if [ "$CI_MODE" = false ]; then
        echo "   ‚úÖ x86_64 build complete"
        echo ""
    fi

    # Build for arm64 (Apple Silicon)
    if [ "$CI_MODE" = false ]; then
        echo "üì¶ Phase 2/3: Building for arm64 (Apple Silicon)..."
    fi

    if ! swift build -c release --arch arm64; then
        echo "‚ùå Error: Failed to build for arm64"
        exit 1
    fi

    if [ "$CI_MODE" = false ]; then
        echo "   ‚úÖ arm64 build complete"
        echo ""
    fi

    # Create release binary using lipo
    if [ "$CI_MODE" = false ]; then
        echo "üîó Phase 3/3: Creating release binary..."
    fi

    BINARY_X86=".build/x86_64-apple-macosx/release/fontlift-mac"
    BINARY_ARM=".build/arm64-apple-macosx/release/fontlift-mac"
    BINARY_UNIVERSAL=".build/release/fontlift-mac"

    # Ensure output directory exists
    mkdir -p .build/release

    # Combine binaries
    if ! lipo -create "${BINARY_X86}" "${BINARY_ARM}" -output "${BINARY_UNIVERSAL}"; then
        echo "‚ùå Error: Failed to create release binary with lipo"
        exit 1
    fi

    BINARY_PATH="${BINARY_UNIVERSAL}"

    if [ "$CI_MODE" = false ]; then
        echo "   ‚úÖ release binary created"
        echo ""
        echo "Architectures in binary:"
        lipo -info "${BINARY_PATH}"
    else
        echo "release binary created: x86_64 + arm64"
    fi
else
    # Standard build for current architecture
    if [ "$CI_MODE" = false ]; then
        echo "üî® Building fontlift-mac (release mode)..."
        echo ""
    fi

    swift build -c release
    BINARY_PATH=".build/release/fontlift-mac"
fi

if [ "$CI_MODE" = false ]; then
    echo ""
    echo "‚úÖ Build complete!"
    echo "üì¶ Binary location: ${BINARY_PATH}"
    if [ "$UNIVERSAL_BUILD" = true ]; then
        echo "üèóÔ∏è  release binary (supports Intel + Apple Silicon)"
    fi
    echo ""
    echo "Run with: .build/release/fontlift-mac --help"
    echo "Install with: ./publish.sh"
else
    if [ "$UNIVERSAL_BUILD" = true ]; then
        echo "‚úÖ Build complete (release): ${BINARY_PATH}"
    else
        echo "‚úÖ Build complete: ${BINARY_PATH}"
    fi
fi
```

## publish.sh
```bash
#!/bin/bash
# this_file: publish.sh
# Install fontlift-mac to /usr/local/bin (local mode) or verify binary (CI mode)
#
# Usage: ./publish.sh [OPTIONS]
#
# Options:
#   --ci        CI mode (skip installation, just verify binary)
#   --help      Show this help message

set -euo pipefail  # Exit on error, undefined vars, pipe failures
cd "$(dirname "$0")"

# Function to display help
show_help() {
    cat << EOF
Usage: $0 [OPTIONS]

Install fontlift-mac to /usr/local/bin (local mode) or verify binary (CI mode).

Options:
  --ci        CI mode (skip installation, just verify binary)
  --help      Show this help message

Examples:
  $0              # Install to /usr/local/bin (local mode)
  $0 --ci         # Verify binary only (CI mode)
  CI=true $0      # Verify binary only (environment variable)

In CI mode:
  - Skips installation (no write to /usr/local/bin)
  - Verifies binary exists and is executable
  - Runs --version and --help to ensure binary works

In local mode:
  - Builds if needed
  - Installs to /usr/local/bin
  - May require sudo permissions
EOF
}

# Parse arguments
CI_MODE=false
if [[ "${CI:-}" == "true" ]]; then
    CI_MODE=true
fi

for arg in "$@"; do
    case $arg in
        --ci)
            CI_MODE=true
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        *)
            echo "‚ùå Error: Unknown option: $arg"
            echo ""
            show_help
            exit 1
            ;;
    esac
done

# Change to project root (where this script is located)
cd "$(dirname "$0")"

INSTALL_DIR="/usr/local/bin"
BINARY_NAME="fontlift-mac"
SOURCE_BINARY=".build/release/${BINARY_NAME}"

# CI mode: Just verify the binary
if [ "$CI_MODE" = true ]; then
    echo "üîç Verifying binary (CI mode)..."

    if [ ! -f "${SOURCE_BINARY}" ]; then
        echo "‚ùå Error: Binary not found at ${SOURCE_BINARY}"
        exit 1
    fi

    if [ ! -x "${SOURCE_BINARY}" ]; then
        echo "‚ùå Error: Binary is not executable"
        exit 1
    fi

    # Test binary works
    echo "Testing binary..."
    "${SOURCE_BINARY}" --version >/dev/null 2>&1
    "${SOURCE_BINARY}" --help >/dev/null 2>&1

    echo "‚úÖ Binary verified successfully"
    exit 0
fi

# Local mode: Install to /usr/local/bin
echo "üì¶ Publishing fontlift-mac to ${INSTALL_DIR}..."
echo ""

# Build if binary doesn't exist
if [ ! -f "${SOURCE_BINARY}" ]; then
    echo "Binary not found. Building first..."
    ./build.sh
    echo ""
fi

# Check if install directory exists
if [ ! -d "${INSTALL_DIR}" ]; then
    echo "‚ùå Error: ${INSTALL_DIR} does not exist"
    exit 1
fi

# Check if binary already exists
if [ -f "${INSTALL_DIR}/${BINARY_NAME}" ]; then
    echo "‚ö†Ô∏è  ${BINARY_NAME} already exists in ${INSTALL_DIR}"
    read -p "Overwrite? (y/N): " -n 1 -r
    echo
    if [[ ! ${REPLY} =~ ^[Yy]$ ]]; then
        echo "Installation cancelled"
        exit 0
    fi
fi

# Copy binary (may require sudo)
echo "Installing ${BINARY_NAME} to ${INSTALL_DIR}..."
if cp "${SOURCE_BINARY}" "${INSTALL_DIR}/${BINARY_NAME}" 2>/dev/null; then
    echo "‚úÖ Installed without sudo"
else
    echo "Need sudo permission to install to ${INSTALL_DIR}"
    sudo cp "${SOURCE_BINARY}" "${INSTALL_DIR}/${BINARY_NAME}"
    echo "‚úÖ Installed with sudo"
fi

# Verify installation
if command -v fontlift-mac &> /dev/null; then
    echo ""
    echo "‚úÖ Installation successful!"
    echo "Version: $(fontlift-mac --version 2>&1 | head -1)"
    echo ""
    echo "Usage: fontlift-mac --help"
else
    echo ""
    echo "‚ö†Ô∏è  Installation complete but fontlift-mac not in PATH"
    echo "You may need to add ${INSTALL_DIR} to your PATH"
fi
```

## scripts/get-version.sh
```bash
#!/bin/bash
# this_file: scripts/get-version.sh
# Extract version from Swift code as fallback when git tags are unreliable
# Usage: ./scripts/get-version.sh

set -euo pipefail

# Change to project root
cd "$(dirname "$0")/.."

# Extract version from Swift code
# The version is defined as: private let version = "X.Y.Z"
CODE_VERSION=$(grep -E 'private let version = "' Sources/fontlift/fontlift.swift | sed -E 's/.*"([0-9]+\.[0-9]+\.[0-9]+)".*/\1/')

if [ -z "$CODE_VERSION" ]; then
    echo "Error: Could not extract version from Sources/fontlift/fontlift.swift" >&2
    echo "Expected line format: private let version = \"X.Y.Z\"" >&2
    exit 1
fi

echo "$CODE_VERSION"
```

## scripts/prepare-release.sh
```bash
#!/bin/bash
# this_file: scripts/prepare-release.sh
# Package fontlift-mac binary for GitHub Release
#
# Usage: ./scripts/prepare-release.sh
#
# Creates: dist/fontlift-mac-vX.Y.Z-macos.tar.gz and checksum file

set -euo pipefail

# Function to display help
show_help() {
    cat << EOF
Usage: $0

Prepares release artifacts for GitHub Release distribution.

Creates:
  - dist/fontlift-mac-vX.Y.Z-macos.tar.gz     Compressed binary tarball
  - dist/fontlift-mac-vX.Y.Z-macos.tar.gz.sha256   SHA256 checksum file

Prerequisites:
  - Release binary must exist at .build/release/fontlift-mac
  - Run ./build.sh first to build the binary

Examples:
  ./build.sh                    # Build first
  $0                            # Prepare release artifacts

The version is extracted from the binary itself using --version.
EOF
}

# Check for help flag
if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    show_help
    exit 0
fi

# Change to project root (where this script's parent is located)
cd "$(dirname "$0")/.."

BINARY_PATH=".build/release/fontlift-mac"
DIST_DIR="dist"

# Verify binary exists
if [ ! -f "${BINARY_PATH}" ]; then
    echo "‚ùå Error: Binary not found at ${BINARY_PATH}"
    echo "Run ./build.sh first to build the release binary"
    exit 1
fi

# Verify binary is executable
if [ ! -x "${BINARY_PATH}" ]; then
    echo "‚ùå Error: Binary is not executable"
    exit 1
fi

echo "üì¶ Extracting version from binary..."
VERSION=$("${BINARY_PATH}" --version 2>&1 | head -1 | awk '{print $NF}')

if [ -z "$VERSION" ]; then
    echo "‚ùå Error: Could not extract version from binary"
    exit 1
fi

echo "Version: $VERSION"

# Create dist directory
mkdir -p "${DIST_DIR}"

# Define artifact names
TARBALL_NAME="fontlift-mac-v${VERSION}-macos.tar.gz"
CHECKSUM_NAME="${TARBALL_NAME}.sha256"
TARBALL_PATH="${DIST_DIR}/${TARBALL_NAME}"
CHECKSUM_PATH="${DIST_DIR}/${CHECKSUM_NAME}"

echo ""
echo "üì¶ Creating release tarball..."

# Create tarball with just the binary
# Use temp directory to avoid including .build path in tarball
TEMP_DIR=$(mktemp -d)
cp "${BINARY_PATH}" "${TEMP_DIR}/fontlift-mac"

# Create tarball from temp directory
tar -czf "${TARBALL_PATH}" -C "${TEMP_DIR}" fontlift-mac

# Clean up temp directory
rm -rf "${TEMP_DIR}"

# Verify tarball was created
if [ ! -f "${TARBALL_PATH}" ]; then
    echo "‚ùå Error: Failed to create tarball"
    exit 1
fi

TARBALL_SIZE=$(du -h "${TARBALL_PATH}" | awk '{print $1}')
echo "‚úÖ Created: ${TARBALL_NAME} (${TARBALL_SIZE})"

# Generate SHA256 checksum
echo ""
echo "üîê Generating SHA256 checksum..."

# Generate checksum (just the filename, not the full path)
(cd "${DIST_DIR}" && shasum -a 256 "${TARBALL_NAME}") > "${CHECKSUM_PATH}"

# Verify checksum file was created
if [ ! -f "${CHECKSUM_PATH}" ]; then
    echo "‚ùå Error: Failed to create checksum file"
    exit 1
fi

CHECKSUM=$(cat "${CHECKSUM_PATH}" | awk '{print $1}')
echo "‚úÖ Created: ${CHECKSUM_NAME}"
echo "Checksum: ${CHECKSUM}"

# Summary
echo ""
echo "‚úÖ Release artifacts prepared successfully!"
echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üìã Release Summary"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
printf "%-20s %s\n" "Version:" "${VERSION}"
printf "%-20s %s\n" "Tarball:" "${TARBALL_NAME}"
printf "%-20s %s\n" "Tarball Size:" "${TARBALL_SIZE}"
printf "%-20s %s\n" "Checksum:" "${CHECKSUM}"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""
echo "To test extraction:"
echo "  tar -xzf ${TARBALL_PATH} && ./fontlift-mac --version"
echo ""
echo "To verify checksum:"
echo "  cd ${DIST_DIR} && shasum -a 256 -c ${CHECKSUM_NAME}"
```

## scripts/validate-version.sh
```bash
#!/bin/bash
# this_file: scripts/validate-version.sh
# Validate that the version in code matches the git tag
#
# Usage: ./scripts/validate-version.sh [TAG_VERSION]
#   TAG_VERSION: Version from git tag (e.g., "1.1.0" from tag "v1.1.0")

set -euo pipefail

# Function to display help
show_help() {
    cat << EOF
Usage: $0 [TAG_VERSION]

Validates that the version constant in code matches the provided tag version.

Arguments:
  TAG_VERSION    Version from git tag (e.g., "1.1.0" from tag "v1.1.0")

Examples:
  $0 1.1.0          # Validate version 1.1.0
  $0 0.2.0          # Validate version 0.2.0

Exit codes:
  0 - Version matches
  1 - Version mismatch or error

Environment:
  Works in both local and CI environments.
EOF
}

# Check for help flag
if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    show_help
    exit 0
fi

# Parse arguments
TAG_VERSION=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            show_help
            exit 0
            ;;
        *)
            if [ -z "$TAG_VERSION" ]; then
                TAG_VERSION="$1"
            fi
            shift
            ;;
    esac
done

# Check if TAG_VERSION was provided
if [ -z "$TAG_VERSION" ]; then
    echo "‚ùå Error: TAG_VERSION argument required"
    echo ""
    show_help
    exit 1
fi

# Ensure tag uses semantic versioning (X.Y.Z)
if [[ ! "$TAG_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo "‚ùå Error: Tag version must follow semantic versioning (X.Y.Z)"
    echo "Received: $TAG_VERSION"
    echo "Example: v1.2.3 ‚Üí pass 1.2.3 to this script"
    exit 1
fi

# Change to project root (where this script's parent is located)
cd "$(dirname "$0")/.."

# Extract version from Swift code
# The version is defined as: private let version = "X.Y.Z"
CODE_VERSION=$(grep -E 'private let version = "' Sources/fontlift/fontlift.swift | sed -E 's/.*"([0-9]+\.[0-9]+\.[0-9]+)".*/\1/')

if [ -z "$CODE_VERSION" ]; then
    echo "‚ùå Error: Could not extract version from Sources/fontlift/fontlift.swift"
    echo "Expected line format: private let version = \"X.Y.Z\""
    exit 1
fi

echo "Tag version:  $TAG_VERSION"
echo "Code version: $CODE_VERSION"
echo ""

# Compare versions
if [ "$TAG_VERSION" == "$CODE_VERSION" ]; then
    echo "‚úÖ Version validation passed!"
    echo "Tag and code versions match: $TAG_VERSION"
    exit 0
else
    echo "‚ö†Ô∏è  Warning: Version mismatch detected"
    echo ""
    echo "The git tag version ($TAG_VERSION) does not match the code version ($CODE_VERSION)"
    echo ""
    echo "Recommendation:"
    echo "  1. Update version in Sources/fontlift/fontlift.swift to: $TAG_VERSION"
    echo "  2. Commit the change"
    echo "  3. Re-create the tag"
    echo ""
    echo "‚ö†Ô∏è  Continuing anyway (validation relaxed)"
    exit 0
fi
```

## test.sh
```bash
#!/bin/bash
# this_file: test.sh
# Run all tests for fontlift-mac
#
# Usage: ./test.sh [OPTIONS]
#
# Options:
#   --ci            CI mode (minimal output, strict error codes)
#   --swift         Run only Swift unit tests
#   --scripts       Run only scripts tests
#   --integration   Run only integration tests
#   --help          Show this help message
#
# Test Suite Breakdown (Total: 131 tests):
#   ‚Ä¢ Swift Unit Tests: 62 tests (CLIErrorTests, HelperFunctionTests, ProjectValidationTests, UnregisterFontTests)
#   ‚Ä¢ Scripts Tests: 23 tests (build.sh, test.sh, publish.sh, validate-version.sh, get-version.sh, binary)
#   ‚Ä¢ Integration Tests: 46 tests (binary metadata, list command, help texts, error handling, output format, sorting/dedup validation, version extraction, cleanup flows)
#
# Note: Test counts in output are hardcoded below and must be updated whenever tests are added or removed.

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Function to display help
show_help() {
    cat << EOF
Usage: $0 [OPTIONS]

Run all tests for fontlift-mac.

Options:
  --ci            CI mode (minimal output, strict error codes)
  --swift         Run only Swift unit tests (62 tests)
  --scripts       Run only scripts tests (23 tests)
  --integration   Run only integration tests (46 tests)
  --help          Show this help message

Examples:
  $0                  # Run all tests (default)
  $0 --ci             # Run all tests in CI mode
  $0 --swift          # Run only Swift unit tests
  $0 --scripts        # Run only scripts tests
  $0 --integration    # Run only integration tests
  $0 --swift --ci     # Run Swift tests in CI mode

Environment:
  CI                  Set to "true" to enable CI mode
EOF
}

# Parse arguments
CI_MODE=false
RUN_SWIFT=true
RUN_SCRIPTS=true
RUN_INTEGRATION=true

if [[ "${CI:-}" == "true" ]]; then
    CI_MODE=true
fi

# Check if any suite-specific flags are set
SUITE_SPECIFIC=false
for arg in "$@"; do
    case $arg in
        --swift|--scripts|--integration)
            SUITE_SPECIFIC=true
            break
            ;;
    esac
done

# If suite-specific flags are present, disable all suites by default
if [ "$SUITE_SPECIFIC" = true ]; then
    RUN_SWIFT=false
    RUN_SCRIPTS=false
    RUN_INTEGRATION=false
fi

for arg in "$@"; do
    case $arg in
        --ci)
            CI_MODE=true
            ;;
        --swift)
            RUN_SWIFT=true
            ;;
        --scripts)
            RUN_SCRIPTS=true
            ;;
        --integration)
            RUN_INTEGRATION=true
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        *)
            echo "‚ùå Error: Unknown option: $arg"
            echo ""
            show_help
            exit 1
            ;;
    esac
done

# Allow callers (like scripts_test.sh) to skip invoking the scripts suite
SKIP_SCRIPT_TESTS="${SKIP_SCRIPT_TESTS:-false}"

# Change to project root (where this script is located)
cd "$(dirname "$0")"

# Verify Swift is installed
if ! command -v swift &> /dev/null; then
    echo "‚ùå Error: Swift is not installed or not in PATH"
    echo "   Try: Install Xcode Command Line Tools with: xcode-select --install"
    exit 1
fi

# Count which suites are running
SUITES_RUNNING=0
if [ "$RUN_SWIFT" = true ]; then ((SUITES_RUNNING++)); fi
if [ "$RUN_SCRIPTS" = true ] && [ "$SKIP_SCRIPT_TESTS" != "true" ]; then ((SUITES_RUNNING++)); fi
if [ "$RUN_INTEGRATION" = true ]; then ((SUITES_RUNNING++)); fi

SUITE_NUM=0

if [ "$CI_MODE" = false ]; then
    echo "üß™ Running fontlift-mac test suite"
    echo ""
fi

# Track total start time
TOTAL_START=$(date +%s)

# Run Swift tests with verbose output
SWIFT_DURATION=0
if [ "$RUN_SWIFT" = true ]; then
    ((SUITE_NUM++))
    if [ "$CI_MODE" = false ]; then
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        if [ "$SUITES_RUNNING" -gt 1 ]; then
            echo "Suite $SUITE_NUM/$SUITES_RUNNING: Swift Unit Tests (62 tests)"
        else
            echo "Swift Unit Tests (62 tests)"
        fi
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
    fi
    SWIFT_START=$(date +%s)
    swift test --parallel
    SWIFT_END=$(date +%s)
    SWIFT_DURATION=$((SWIFT_END - SWIFT_START))
fi

if [ "$CI_MODE" = false ]; then
    echo ""
fi

# Run scripts tests if they exist and we're not skipping them
SCRIPTS_DURATION=0
should_run_scripts_tests=true
if [[ "$SKIP_SCRIPT_TESTS" == "true" || "$SKIP_SCRIPT_TESTS" == "1" ]]; then
    should_run_scripts_tests=false
fi

if [ "$RUN_SCRIPTS" = true ] && [ "$should_run_scripts_tests" = true ] && [ -f "Tests/scripts_test.sh" ]; then
    ((SUITE_NUM++))
    if [ "$CI_MODE" = false ]; then
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        if [ "$SUITES_RUNNING" -gt 1 ]; then
            echo "Suite $SUITE_NUM/$SUITES_RUNNING: Scripts Tests (23 tests)"
        else
            echo "Scripts Tests (23 tests)"
        fi
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
    fi
    SCRIPTS_START=$(date +%s)
    ./Tests/scripts_test.sh
    SCRIPTS_END=$(date +%s)
    SCRIPTS_DURATION=$((SCRIPTS_END - SCRIPTS_START))
fi

# Run integration tests if they exist
INTEGRATION_DURATION=0
if [ "$RUN_INTEGRATION" = true ] && [ -f "Tests/integration_test.sh" ]; then
    ((SUITE_NUM++))
    if [ "$CI_MODE" = false ]; then
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        if [ "$SUITES_RUNNING" -gt 1 ]; then
            echo "Suite $SUITE_NUM/$SUITES_RUNNING: Integration Tests (46 tests)"
        else
            echo "Integration Tests (46 tests)"
        fi
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
    fi
    INTEGRATION_START=$(date +%s)
    ./Tests/integration_test.sh
    INTEGRATION_END=$(date +%s)
    INTEGRATION_DURATION=$((INTEGRATION_END - INTEGRATION_START))
fi

TOTAL_END=$(date +%s)
TOTAL_DURATION=$((TOTAL_END - TOTAL_START))

# Calculate total test count based on what ran
TOTAL_TESTS=0
if [ "$RUN_SWIFT" = true ]; then
    TOTAL_TESTS=$((TOTAL_TESTS + 60))
fi
if [ "$RUN_SCRIPTS" = true ] && [ "$SKIP_SCRIPT_TESTS" != "true" ]; then
    TOTAL_TESTS=$((TOTAL_TESTS + 23))
fi
if [ "$RUN_INTEGRATION" = true ]; then
    TOTAL_TESTS=$((TOTAL_TESTS + 46))  # 42 base + 2 performance + 2 version extraction
fi

if [ "$CI_MODE" = false ]; then
    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "‚úÖ All Tests Passed! ($TOTAL_TESTS total)"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo ""
    echo "Test Execution Times:"
    if [ "$RUN_SWIFT" = true ]; then
echo "  ‚Ä¢ Swift unit tests:       ${SWIFT_DURATION}s (62 tests)"
    fi
    if [ "$RUN_SCRIPTS" = true ] && [ "$SKIP_SCRIPT_TESTS" != "true" ]; then
        echo "  ‚Ä¢ Scripts tests:          ${SCRIPTS_DURATION}s (23 tests)"
    fi
    if [ "$RUN_INTEGRATION" = true ]; then
        echo "  ‚Ä¢ Integration tests:      ${INTEGRATION_DURATION}s (46 tests)"
    fi
    echo "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "  ‚Ä¢ Total:                  ${TOTAL_DURATION}s"
    echo ""
else
    echo "‚úÖ All tests passed"
fi
```